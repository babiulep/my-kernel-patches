diff -rupN a/common/inc/nv-linux.h b/common/inc/nv-linux.h
--- a/common/inc/nv-linux.h	2025-11-21 14:44:37.000000000 +0100
+++ b/common/inc/nv-linux.h	2025-12-08 14:45:05.000000000 +0100
@@ -642,9 +642,9 @@ static inline dma_addr_t nv_phys_to_dma(
 #define NV_PRINT_AT(nv_debug_level,at)                                           \
     {                                                                            \
         nv_printf(nv_debug_level,                                                \
-            "NVRM: VM: %s:%d: 0x%p, %d page(s), count = %d, "                    \
+            "NVRM: VM: %s:%d: 0x%p, %d page(s), count = %lld, "                    \
             "page_table = 0x%p\n",  __FUNCTION__, __LINE__, at,                  \
-            at->num_pages, NV_ATOMIC_READ(at->usage_count),                      \
+            at->num_pages, (long long)atomic64_read(&at->usage_count),                      \
             at->page_table);                                                     \
     }
 
@@ -901,7 +901,7 @@ typedef struct nvidia_pte_s {
 typedef struct nv_alloc_s {
     struct nv_alloc_s *next;
     struct device     *dev;
-    atomic_t       usage_count;
+    atomic64_t       usage_count;
     struct {
         NvBool contig      : 1;
         NvBool guest       : 1;
@@ -1230,7 +1230,7 @@ struct nv_pci_tegra_devfreq_dev;
 typedef struct nv_linux_state_s {
     nv_state_t nv_state;
 
-    atomic_t   usage_count;
+    atomic64_t usage_count;
 
     NvU32    suspend_count;
 
@@ -1596,9 +1596,9 @@ static inline NvBool nv_alloc_release(nv
 {
     NV_PRINT_AT(NV_DBG_MEMINFO, at);
 
-    if (NV_ATOMIC_DEC_AND_TEST(at->usage_count))
+    if (atomic64_dec_and_test(&at->usage_count))
     {
-        NV_ATOMIC_INC(at->usage_count);
+        atomic64_inc(&at->usage_count);
 
         at->next = nvlfp->free_list;
         nvlfp->free_list = at;
diff -rupN a/common/inc/nv-mm.h b/common/inc/nv-mm.h
--- a/common/inc/nv-mm.h	2025-11-21 14:44:03.000000000 +0100
+++ b/common/inc/nv-mm.h	2025-12-08 14:44:27.000000000 +0100
@@ -200,14 +200,33 @@ static inline struct rw_semaphore *nv_mm
  * Commit 45ad9f5290dc updated vma_start_write() to call __vma_start_write().
  */
 void nv_vma_start_write(struct vm_area_struct *);
+
+static inline void nv_vma_flags_set_word(struct vm_area_struct *vma, unsigned long flags)
+{
+    nv_vma_start_write(vma);
+#if defined(NV_VMA_FLAGS_SET_WORD_PRESENT)
+    vma_flags_set_word(&vma->flags, flags);
+#else
+    ACCESS_PRIVATE(vma, __vm_flags) |= flags;
 #endif
+}
+
+static inline void nv_vma_flags_clear_word(struct vm_area_struct *vma, unsigned long flags)
+{
+    nv_vma_start_write(vma);
+#if defined(NV_VMA_FLAGS_SET_WORD_PRESENT)
+    vma_flags_clear_word(&vma->flags, flags);
+#else
+    ACCESS_PRIVATE(vma, __vm_flags) &= ~flags;
+#endif
+}
+#endif // !NV_CAN_CALL_VMA_START_WRITE
 
 static inline void nv_vm_flags_set(struct vm_area_struct *vma, vm_flags_t flags)
 {
 #if !NV_CAN_CALL_VMA_START_WRITE
-    nv_vma_start_write(vma);
-    ACCESS_PRIVATE(vma, __vm_flags) |= flags;
-#elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
+    nv_vma_flags_set_word(vma, flags);
+#elif defined(NV_VM_FLAGS_SET_PRESENT)
     vm_flags_set(vma, flags);
 #else
     vma->vm_flags |= flags;
@@ -217,9 +236,8 @@ static inline void nv_vm_flags_set(struc
 static inline void nv_vm_flags_clear(struct vm_area_struct *vma, vm_flags_t flags)
 {
 #if !NV_CAN_CALL_VMA_START_WRITE
-    nv_vma_start_write(vma);
-    ACCESS_PRIVATE(vma, __vm_flags) &= ~flags;
-#elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
+    nv_vma_flags_clear_word(vma, flags);
+#elif defined(NV_VM_FLAGS_SET_PRESENT)
     vm_flags_clear(vma, flags);
 #else
     vma->vm_flags &= ~flags;
diff -rupN a/common/inc/nv-time.h b/common/inc/nv-time.h
--- a/common/inc/nv-time.h	2025-11-21 14:44:01.000000000 +0100
+++ b/common/inc/nv-time.h	2025-12-08 14:44:24.000000000 +0100
@@ -36,6 +36,19 @@
 #define NV_MAX_ISR_DELAY_MS           (NV_MAX_ISR_DELAY_US / 1000)
 #define NV_NSECS_TO_JIFFIES(nsec)     ((nsec) * HZ / 1000000000)
 
+/*
+ * in_hardirq() was added in v5.11-rc1 (2020-12-15) to replace in_irq().
+ * Fall back to in_irq() for older kernels that don't have in_hardirq().
+ */
+static inline NvBool nv_in_hardirq(void)
+{
+#if defined(in_hardirq)
+    return in_hardirq();
+#else
+    return in_irq();
+#endif
+}
+
 #if !defined(NV_KTIME_GET_RAW_TS64_PRESENT)
 static inline void ktime_get_raw_ts64(struct timespec64 *ts64)
 {
@@ -82,7 +95,7 @@ static inline NV_STATUS nv_sleep_us(unsi
     ktime_get_raw_ts64(&tm1);
 #endif
 
-    if (in_irq() && (us > NV_MAX_ISR_DELAY_US))
+    if (nv_in_hardirq() && (us > NV_MAX_ISR_DELAY_US))
         return NV_ERR_GENERIC;
 
     mdelay_safe_msec = us / 1000;
@@ -127,7 +140,7 @@ static inline NV_STATUS nv_sleep_ms(unsi
     tm_start = tm_aux;
 #endif
 
-    if (in_irq() && (ms > NV_MAX_ISR_DELAY_MS))
+    if (nv_in_hardirq() && (ms > NV_MAX_ISR_DELAY_MS))
     {
         return NV_ERR_GENERIC;
     }
diff -rupN a/conftest.sh b/conftest.sh
--- a/conftest.sh	2025-11-21 13:39:41.000000000 +0100
+++ b/conftest.sh	2025-12-08 13:27:09.000000000 +0100
@@ -2114,6 +2114,35 @@ compile_test() {
             compile_check_conftest "$CODE" "NV_GET_BACKLIGHT_DEVICE_BY_NAME_PRESENT" "" "functions"
         ;;
 
+        dma_map_ops_has_map_phys)
+            #
+            # Determine if .map_phys exists in struct dma_map_ops.
+            #
+            # Commit 14cb413af00c ("dma-mapping: remove unused mapping resource callbacks")
+            # removed .map_resource operation and replaced it with .map_phys.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/dma-map-ops.h>
+            int conftest_dma_map_ops_has_map_phys(void) {
+                return offsetof(struct dma_map_ops, map_phys);
+            }
+            int conftest_dma_map_ops_has_unmap_phys(void) {
+                return offsetof(struct dma_map_ops, unmap_phys);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_DMA_MAP_OPS_HAS_MAP_PHYS" | append_conftest "types"
+                rm -f conftest$$.o
+                return
+            else
+                echo "#undef NV_DMA_MAP_OPS_HAS_MAP_PHYS" | append_conftest "types"
+                return
+            fi
+        ;;
+
         dma_buf_ops_has_map)
             #
             # Determine if .map exists in dma_buf_ops.
@@ -3938,6 +3967,27 @@ compile_test() {
             compile_check_conftest "$CODE" "NV_PCI_REBAR_GET_POSSIBLE_SIZES_PRESENT" "" "functions"
         ;;
 
+        pci_resize_resource_has_exclude_bars_arg)
+            #
+            # Determine if pci_resize_resource() has exclude_bars argument.
+            #
+            # exclude_bars argument was added to pci_resize_resource by commit
+            # 337b1b566db0 (11/14/2025) ("PCI: Fix restoring BARs on BAR resize rollback path")
+            # in linux-next.
+            #
+            CODE="
+            #include <linux/pci.h>
+
+            typeof(pci_resize_resource) conftest_pci_resize_resource_has_exclude_bars_arg;
+            int __must_check conftest_pci_resize_resource_has_exclude_bars_arg(struct pci_dev *dev,
+                                                                               int i, int size,
+                                                                               int exclude_bars) {
+                return 0;
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_RESIZE_RESOURCE_HAS_EXCLUDE_BARS_ARG" "" "types"
+        ;;
+
         drm_connector_has_override_edid)
             #
             # Determine if 'struct drm_connector' has an 'override_edid' member.
@@ -3976,22 +4026,39 @@ compile_test() {
             compile_check_conftest "$CODE" "NV_IOMMU_SVA_BIND_DEVICE_HAS_DRVDATA_ARG" "" "types"
         ;;
 
-        vm_area_struct_has_const_vm_flags)
+        vm_flags_set)
             #
-            # Determine if the 'vm_area_struct' structure has
-            # const 'vm_flags'.
+            # Determine if the vm_flags_set() function is present. The
+            # presence of this function indicates that the vm_flags_clear()
+            # function is also present.
             #
-            # A union of '__vm_flags' and 'const vm_flags' was added by
+            # The functions vm_flags_set()/ vm_flags_clear() were added by
             # commit bc292ab00f6c ("mm: introduce vma->vm_flags wrapper
-            # functions") in v6.3.
+            # functions") in v6.3-rc1 (2023-02-09).
             #
             CODE="
-            #include <linux/mm_types.h>
-            int conftest_vm_area_struct_has_const_vm_flags(void) {
-                return offsetof(struct vm_area_struct, __vm_flags);
+            #include <linux/mm.h>
+            void conftest_vm_flags_set(void) {
+                vm_flags_set();
+            }"
+
+            compile_check_conftest "$CODE" "NV_VM_FLAGS_SET_PRESENT" "" "functions"
+        ;;
+
+        vma_flags_set_word)
+            #
+            # Determine if the vma_flags_set_word() function is present.
+            #
+            # Added by commit c3f7c506e8f1 ("mm: introduce VMA flags bitmap type")
+            # in v6.19-rc1.
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_vma_flags_set_word(void) {
+                vma_flags_set_word();
             }"
 
-            compile_check_conftest "$CODE" "NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS" "" "types"
+            compile_check_conftest "$CODE" "NV_VMA_FLAGS_SET_WORD_PRESENT" "" "functions"
         ;;
 
         drm_driver_has_dumb_destroy)
diff -rupN a/nvidia/nv.c b/nvidia/nv.c
--- a/nvidia/nv.c	2025-11-21 14:44:33.000000000 +0100
+++ b/nvidia/nv.c	2025-12-08 14:45:01.000000000 +0100
@@ -382,7 +382,7 @@ nv_alloc_t *nvos_create_alloc(
         return NULL;
     }
 
-    NV_ATOMIC_SET(at->usage_count, 0);
+    atomic64_set(&at->usage_count, 0);
     at->pid = os_get_current_process();
     at->dev = dev;
 
@@ -397,7 +397,7 @@ int nvos_free_alloc(
     if (at == NULL)
         return -1;
 
-    if (NV_ATOMIC_READ(at->usage_count))
+    if (atomic64_read(&at->usage_count))
         return 1;
 
     kvfree(at->page_table);
@@ -1631,13 +1631,10 @@ static int nv_open_device(nv_state_t *nv
         return -ENODEV;
     }
 
-    if (unlikely(NV_ATOMIC_READ(nvl->usage_count) >= NV_S32_MAX))
-        return -EMFILE;
-
     if ( ! (nv->flags & NV_FLAG_OPEN))
     {
         /* Sanity check: !NV_FLAG_OPEN requires usage_count == 0 */
-        if (NV_ATOMIC_READ(nvl->usage_count) != 0)
+        if (atomic64_read(&nvl->usage_count) != 0)
         {
             NV_DEV_PRINTF(NV_DBG_ERRORS, nv,
                           "Minor device %u is referenced without being open!\n",
@@ -1659,7 +1656,7 @@ static int nv_open_device(nv_state_t *nv
 
     nv_assert_not_in_gpu_exclusion_list(sp, nv);
 
-    NV_ATOMIC_INC(nvl->usage_count);
+    atomic64_inc(&nvl->usage_count);
 
     return 0;
 }
@@ -2075,7 +2072,7 @@ static void nv_close_device(nv_state_t *
 {
     nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
 
-    if (NV_ATOMIC_READ(nvl->usage_count) == 0)
+    if (atomic64_read(&nvl->usage_count) == 0)
     {
         nv_printf(NV_DBG_ERRORS,
                   "NVRM: Attempting to close unopened minor device %u!\n",
@@ -2084,7 +2081,7 @@ static void nv_close_device(nv_state_t *
         return;
     }
 
-    if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
+    if (atomic64_dec_and_test(&nvl->usage_count))
         nv_stop_device(nv, sp);
 }
 
@@ -2129,7 +2126,7 @@ nvidia_close_callback(
     nv_close_device(nv, sp);
 
     bRemove = (!NV_IS_DEVICE_IN_SURPRISE_REMOVAL(nv)) &&
-              (NV_ATOMIC_READ(nvl->usage_count) == 0) &&
+              (atomic64_read(&nvl->usage_count) == 0) &&
               rm_get_device_remove_flag(sp, nv->gpu_id);
 
     nv_free_file_private(nvlfp);
@@ -2148,7 +2145,7 @@ nvidia_close_callback(
      * any cleanup related to linux layer locks and nv linux state struct.
      * nvidia_pci_remove when scheduled will do necessary cleanup.
      */
-    if ((NV_ATOMIC_READ(nvl->usage_count) == 0) && nv->removed)
+    if ((atomic64_read(&nvl->usage_count) == 0) && nv->removed)
     {
         nv_lock_destroy_locks(sp, nv);
         NV_KFREE(nvl, sizeof(nv_linux_state_t));
@@ -2668,7 +2665,7 @@ nvidia_ioctl(
                      * Only the current client should have an open file
                      * descriptor for the device, to allow safe offlining.
                      */
-                    if (NV_ATOMIC_READ(nvl->usage_count) > 1)
+                    if (atomic64_read(&nvl->usage_count) > 1)
                     {
                         status = -EBUSY;
                         goto unlock;
@@ -3057,12 +3054,12 @@ nvidia_ctl_open(
     /* save the nv away in file->private_data */
     nvlfp->nvptr = nvl;
 
-    if (NV_ATOMIC_READ(nvl->usage_count) == 0)
+    if (atomic64_read(&nvl->usage_count) == 0)
     {
         nv->flags |= (NV_FLAG_OPEN | NV_FLAG_CONTROL);
     }
 
-    NV_ATOMIC_INC(nvl->usage_count);
+    atomic64_inc(&nvl->usage_count);
     up(&nvl->ldata_lock);
 
     return 0;
@@ -3087,7 +3084,7 @@ nvidia_ctl_close(
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_close\n");
 
     down(&nvl->ldata_lock);
-    if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
+    if (atomic64_dec_and_test(&nvl->usage_count))
     {
         nv->flags &= ~NV_FLAG_OPEN;
     }
@@ -3250,7 +3247,7 @@ nv_alias_pages(
 
     at->guest_id = guest_id;
     *priv_data = at;
-    NV_ATOMIC_INC(at->usage_count);
+    atomic64_inc(&at->usage_count);
 
     NV_PRINT_AT(NV_DBG_MEMINFO, at);
 
@@ -3563,7 +3560,7 @@ NV_STATUS NV_API_CALL nv_register_sgt(
 
     at->order = get_order(at->num_pages * PAGE_SIZE);
 
-    NV_ATOMIC_INC(at->usage_count);
+    atomic64_inc(&at->usage_count);
 
     *priv_data = at;
 
@@ -3594,7 +3591,7 @@ void NV_API_CALL nv_unregister_sgt(
         *import_priv = at->import_priv;
     }
 
-    if (NV_ATOMIC_DEC_AND_TEST(at->usage_count))
+    if (atomic64_dec_and_test(&at->usage_count))
     {
         nvos_free_alloc(at);
     }
@@ -3867,7 +3864,7 @@ NV_STATUS NV_API_CALL nv_alloc_pages(
     }
 
     *priv_data = at;
-    NV_ATOMIC_INC(at->usage_count);
+    atomic64_inc(&at->usage_count);
 
     NV_PRINT_AT(NV_DBG_MEMINFO, at);
 
@@ -3903,7 +3900,7 @@ NV_STATUS NV_API_CALL nv_free_pages(
      * This is described in greater detail in the comments above the
      * nvidia_vma_(open|release)() callbacks in nv-mmap.c.
      */
-    if (!NV_ATOMIC_DEC_AND_TEST(at->usage_count))
+    if (!atomic64_dec_and_test(&at->usage_count))
         return NV_OK;
 
     if (!at->flags.guest && !at->import_sgt)
@@ -3932,7 +3929,7 @@ NvBool nv_lock_init_locks
     NV_INIT_MUTEX(&nvl->mmap_lock);
     NV_INIT_MUTEX(&nvl->open_q_lock);
 
-    NV_ATOMIC_SET(nvl->usage_count, 0);
+    atomic64_set(&nvl->usage_count, 0);
 
     if (!rm_init_event_locks(sp, nv))
         return NV_FALSE;
diff -rupN a/nvidia/nv-dma.c b/nvidia/nv-dma.c
--- a/nvidia/nv-dma.c	2025-11-21 14:44:33.000000000 +0100
+++ b/nvidia/nv-dma.c	2025-12-08 14:45:02.000000000 +0100
@@ -729,7 +729,11 @@ static NvBool nv_dma_use_map_resource
 #endif
     }
 
+#if defined(NV_DMA_MAP_OPS_HAS_MAP_PHYS)
+    return (ops->map_phys != NULL);
+#else
     return (ops->map_resource != NULL);
+#endif
 }
 
 /* DMA-map a peer device's C2C aperture for peer access. */
diff -rupN a/nvidia/nvidia.Kbuild b/nvidia/nvidia.Kbuild
--- a/nvidia/nvidia.Kbuild	2025-11-21 14:43:57.000000000 +0100
+++ b/nvidia/nvidia.Kbuild	2025-12-08 14:44:19.000000000 +0100
@@ -141,6 +141,7 @@ NV_CONFTEST_FUNCTION_COMPILE_TESTS += ic
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += devm_of_icc_get
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += icc_put
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += icc_set_bw
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += dma_map_ops_has_map_phys
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += dma_buf_ops_has_map
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += dma_buf_ops_has_map_atomic
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += dma_buf_attachment_has_peer2peer
@@ -159,6 +160,8 @@ NV_CONFTEST_FUNCTION_COMPILE_TESTS += io
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += mm_pasid_drop
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += iommu_sva_bind_device_has_drvdata_arg
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += shrinker_alloc
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += vm_flags_set
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += vma_flags_set_word
 
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_gpl_sme_active
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_present_swiotlb_map_sg_attrs
@@ -206,7 +209,6 @@ NV_CONFTEST_TYPE_COMPILE_TESTS += remove
 NV_CONFTEST_TYPE_COMPILE_TESTS += add_memory_driver_managed_has_mhp_flags_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += num_registered_fb
 NV_CONFTEST_TYPE_COMPILE_TESTS += pci_driver_has_driver_managed_dma
-NV_CONFTEST_TYPE_COMPILE_TESTS += vm_area_struct_has_const_vm_flags
 NV_CONFTEST_TYPE_COMPILE_TESTS += memory_failure_queue_has_trapno_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += foll_longterm_present
 NV_CONFTEST_TYPE_COMPILE_TESTS += bus_type_has_iommu_ops
@@ -220,6 +222,7 @@ NV_CONFTEST_TYPE_COMPILE_TESTS += devfre
 NV_CONFTEST_TYPE_COMPILE_TESTS += has_enum_pidtype_tgid
 NV_CONFTEST_TYPE_COMPILE_TESTS += bpmp_mrq_has_strap_set
 NV_CONFTEST_TYPE_COMPILE_TESTS += register_shrinker_has_format_arg
+NV_CONFTEST_TYPE_COMPILE_TESTS += pci_resize_resource_has_exclude_bars_arg
 
 NV_CONFTEST_GENERIC_COMPILE_TESTS += dom0_kernel_present
 NV_CONFTEST_GENERIC_COMPILE_TESTS += nvidia_vgpu_kvm_build
Binary files a/nvidia/nv-kernel.o_binary and b/nvidia/nv-kernel.o_binary differ
diff -rupN a/nvidia/nv-mmap.c b/nvidia/nv-mmap.c
--- a/nvidia/nv-mmap.c	2025-11-21 14:44:34.000000000 +0100
+++ b/nvidia/nv-mmap.c	2025-12-08 14:45:02.000000000 +0100
@@ -72,7 +72,7 @@ nvidia_vma_open(struct vm_area_struct *v
 
     if (at != NULL)
     {
-        NV_ATOMIC_INC(at->usage_count);
+        atomic64_inc(&at->usage_count);
 
         NV_PRINT_AT(NV_DBG_MEMINFO, at);
     }
@@ -414,7 +414,7 @@ static int nvidia_mmap_sysmem(
     int ret = 0;
     unsigned long start = 0;
 
-    NV_ATOMIC_INC(at->usage_count);
+    atomic64_inc(&at->usage_count);
 
     start = vma->vm_start;
     for (j = page_index; j < (page_index + pages); j++)
@@ -450,7 +450,7 @@ static int nvidia_mmap_sysmem(
 
         if (ret)
         {
-            NV_ATOMIC_DEC(at->usage_count);
+            atomic64_dec(&at->usage_count);
             nv_printf(NV_DBG_ERRORS,
                       "NVRM: Userspace mapping creation failed [%d]!\n", ret);
             return -EAGAIN;
diff -rupN a/nvidia/nv-pci.c b/nvidia/nv-pci.c
--- a/nvidia/nv-pci.c	2025-11-21 14:44:33.000000000 +0100
+++ b/nvidia/nv-pci.c	2025-12-08 14:45:01.000000000 +0100
@@ -272,11 +272,6 @@ nv_pci_probe
     nv_printf(NV_DBG_SETUP, "NVRM: probing 0x%x 0x%x, class 0x%x\n",
         pci_dev->vendor, pci_dev->device, pci_dev->class);
 
-    if (nv_kmem_cache_alloc_stack(&sp) != 0)
-    {
-        return -1;
-    }
-
 #ifdef NV_PCI_SRIOV_SUPPORT
     if (pci_dev->is_virtfn)
     {
@@ -292,21 +287,25 @@ nv_pci_probe
                       "since IOMMU is not present on the system.\n",
                        NV_PCI_DOMAIN_NUMBER(pci_dev), NV_PCI_BUS_NUMBER(pci_dev),
                        NV_PCI_SLOT_NUMBER(pci_dev), PCI_FUNC(pci_dev->devfn));
-            goto failed;
+            return -1;
         }
 
-        nv_kmem_cache_free_stack(sp);
         return 0;
 #else
         nv_printf(NV_DBG_ERRORS, "NVRM: Ignoring probe for VF %04x:%02x:%02x.%x ",
                   NV_PCI_DOMAIN_NUMBER(pci_dev), NV_PCI_BUS_NUMBER(pci_dev),
                   NV_PCI_SLOT_NUMBER(pci_dev), PCI_FUNC(pci_dev->devfn));
 
-        goto failed;
+        return -1;
 #endif /* NV_VGPU_KVM_BUILD */
     }
 #endif /* NV_PCI_SRIOV_SUPPORT */
 
+    if (nv_kmem_cache_alloc_stack(&sp) != 0)
+    {
+        return -1;
+    }
+
     if (!rm_wait_for_bar_firewall(
                 sp,
                 NV_PCI_DOMAIN_NUMBER(pci_dev),
@@ -683,7 +682,7 @@ nv_pci_remove(struct pci_dev *pci_dev)
      * For eGPU, fall off the bus along with clients active is a valid scenario.
      * Hence skipping the sanity check for eGPU.
      */
-    if ((NV_ATOMIC_READ(nvl->usage_count) != 0) && !(nv->is_external_gpu))
+    if ((atomic64_read(&nvl->usage_count) != 0) && !(nv->is_external_gpu))
     {
         nv_printf(NV_DBG_ERRORS,
                   "NVRM: Attempting to remove device %04x:%02x:%02x.%x with non-zero usage count!\n",
@@ -694,7 +693,7 @@ nv_pci_remove(struct pci_dev *pci_dev)
          * We can't return from this function without corrupting state, so we wait for
          * the usage count to go to zero.
          */
-        while (NV_ATOMIC_READ(nvl->usage_count) != 0)
+        while (atomic64_read(&nvl->usage_count) != 0)
         {
 
             /*
@@ -768,7 +767,7 @@ nv_pci_remove(struct pci_dev *pci_dev)
         nvl->sysfs_config_file = NULL;
     }
 
-    if (NV_ATOMIC_READ(nvl->usage_count) == 0)
+    if (atomic64_read(&nvl->usage_count) == 0)
     {
         nv_lock_destroy_locks(sp, nv);
     }
@@ -784,7 +783,7 @@ nv_pci_remove(struct pci_dev *pci_dev)
 
     num_nv_devices--;
 
-    if (NV_ATOMIC_READ(nvl->usage_count) == 0)
+    if (atomic64_read(&nvl->usage_count) == 0)
     {
         NV_PCI_DISABLE_DEVICE(pci_dev);
         NV_KFREE(nvl, sizeof(nv_linux_state_t));
diff -rupN a/nvidia/nv-procfs.c b/nvidia/nv-procfs.c
--- a/nvidia/nv-procfs.c	2025-11-21 14:44:34.000000000 +0100
+++ b/nvidia/nv-procfs.c	2025-12-08 14:45:02.000000000 +0100
@@ -890,7 +890,7 @@ nv_procfs_close_unbind_lock(
         down(&nvl->ldata_lock);
         if ((value == 1) && !(nv->flags & NV_FLAG_UNBIND_LOCK))
         {
-            if (NV_ATOMIC_READ(nvl->usage_count) == 0)
+            if (atomic64_read(&nvl->usage_count) == 0)
                 rm_unbind_lock(sp, nv);
 
             if (nv->flags & NV_FLAG_UNBIND_LOCK)
diff -rupN a/nvidia/os-interface.c b/nvidia/os-interface.c
--- a/nvidia/os-interface.c	2025-11-21 14:44:35.000000000 +0100
+++ b/nvidia/os-interface.c	2025-12-08 14:45:03.000000000 +0100
@@ -341,7 +341,7 @@ NvBool NV_API_CALL os_semaphore_may_slee
 
 NvBool NV_API_CALL os_is_isr(void)
 {
-    return (in_irq());
+    return (nv_in_hardirq());
 }
 
 // return TRUE if the caller is the super-user
diff -rupN a/nvidia-drm/nvidia-drm-crtc.c b/nvidia-drm/nvidia-drm-crtc.c
--- a/nvidia-drm/nvidia-drm-crtc.c	2025-11-21 14:03:11.000000000 +0100
+++ b/nvidia-drm/nvidia-drm-crtc.c	2025-12-08 13:50:02.000000000 +0100
@@ -1554,7 +1554,7 @@ static int __nv_drm_cursor_atomic_check(
 
     WARN_ON(nv_plane->layer_idx != NVKMS_KAPI_LAYER_INVALID_IDX);
 
-    nv_drm_for_each_crtc_in_state(plane_state->state, crtc, crtc_state, i) {
+    for_each_new_crtc_in_state(plane_state->state, crtc, crtc_state, i) {
         struct nv_drm_crtc_state *nv_crtc_state = to_nv_crtc_state(crtc_state);
         struct NvKmsKapiHeadRequestedConfig *head_req_config =
             &nv_crtc_state->req_config;
@@ -1600,7 +1600,7 @@ static int nv_drm_plane_atomic_check(str
 
     WARN_ON(nv_plane->layer_idx == NVKMS_KAPI_LAYER_INVALID_IDX);
 
-    nv_drm_for_each_crtc_in_state(plane_state->state, crtc, crtc_state, i) {
+    for_each_new_crtc_in_state(plane_state->state, crtc, crtc_state, i) {
         struct nv_drm_crtc_state *nv_crtc_state = to_nv_crtc_state(crtc_state);
         struct NvKmsKapiHeadRequestedConfig *head_req_config =
             &nv_crtc_state->req_config;
@@ -2430,7 +2430,7 @@ static int nv_drm_crtc_atomic_check(stru
 
         req_config->flags.displaysChanged = NV_TRUE;
 
-        nv_drm_for_each_connector_in_state(crtc_state->state,
+        for_each_new_connector_in_state(crtc_state->state,
                                            connector, connector_state, j) {
             if (connector_state->crtc != crtc) {
                 continue;
diff -rupN a/nvidia-drm/nvidia-drm-helper.c b/nvidia-drm/nvidia-drm-helper.c
--- a/nvidia-drm/nvidia-drm-helper.c	2025-11-21 14:03:11.000000000 +0100
+++ b/nvidia-drm/nvidia-drm-helper.c	2025-12-08 13:50:01.000000000 +0100
@@ -54,7 +54,7 @@
  * drm_atomic_helper_disable_all() is copied from
  * linux/drivers/gpu/drm/drm_atomic_helper.c and modified to use
  * nv_drm_for_each_crtc instead of drm_for_each_crtc to loop over all crtcs,
- * use nv_drm_for_each_*_in_state instead of for_each_connector_in_state to loop
+ * use for_each_new_*_in_state instead of for_each_connector_in_state to loop
  * over all modeset object states, and use drm_atomic_state_free() if
  * drm_atomic_state_put() is not available.
  *
@@ -139,13 +139,13 @@ int nv_drm_atomic_helper_disable_all(str
         plane_state->rotation = DRM_MODE_ROTATE_0;
     }
 
-    nv_drm_for_each_connector_in_state(state, conn, conn_state, i) {
+    for_each_new_connector_in_state(state, conn, conn_state, i) {
         ret = drm_atomic_set_crtc_for_connector(conn_state, NULL);
         if (ret < 0)
             goto free;
     }
 
-    nv_drm_for_each_plane_in_state(state, plane, plane_state, i) {
+    for_each_new_plane_in_state(state, plane, plane_state, i) {
         ret = drm_atomic_set_crtc_for_plane(plane_state, NULL);
         if (ret < 0)
             goto free;
diff -rupN a/nvidia-drm/nvidia-drm-helper.h b/nvidia-drm/nvidia-drm-helper.h
--- a/nvidia-drm/nvidia-drm-helper.h	2025-11-21 14:03:09.000000000 +0100
+++ b/nvidia-drm/nvidia-drm-helper.h	2025-12-08 13:49:59.000000000 +0100
@@ -138,154 +138,6 @@ nv_drm_prime_pages_to_sg(struct drm_devi
 int nv_drm_atomic_helper_disable_all(struct drm_device *dev,
                                      struct drm_modeset_acquire_ctx *ctx);
 
-/*
- * for_each_connector_in_state(), for_each_crtc_in_state() and
- * for_each_plane_in_state() were added by kernel commit
- * df63b9994eaf942afcdb946d27a28661d7dfbf2a which was Signed-off-by:
- *      Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
- *      Daniel Vetter <daniel.vetter@ffwll.ch>
- *
- * for_each_connector_in_state(), for_each_crtc_in_state() and
- * for_each_plane_in_state() were copied from
- *      include/drm/drm_atomic.h @
- *      21a01abbe32a3cbeb903378a24e504bfd9fe0648
- * which has the following copyright and license information:
- *
- * Copyright (C) 2014 Red Hat
- * Copyright (C) 2014 Intel Corp.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- * Rob Clark <robdclark@gmail.com>
- * Daniel Vetter <daniel.vetter@ffwll.ch>
- */
-
-/**
- * nv_drm_for_each_connector_in_state - iterate over all connectors in an
- * atomic update
- * @__state: &struct drm_atomic_state pointer
- * @connector: &struct drm_connector iteration cursor
- * @connector_state: &struct drm_connector_state iteration cursor
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all connectors in an atomic update. Note that before the
- * software state is committed (by calling drm_atomic_helper_swap_state(), this
- * points to the new state, while afterwards it points to the old state. Due to
- * this tricky confusion this macro is deprecated.
- */
-#if !defined(for_each_connector_in_state)
-#define nv_drm_for_each_connector_in_state(__state,                         \
-                                           connector, connector_state, __i) \
-       for ((__i) = 0;                                                      \
-            (__i) < (__state)->num_connector &&                             \
-            ((connector) = (__state)->connectors[__i].ptr,                  \
-            (connector_state) = (__state)->connectors[__i].state, 1);       \
-            (__i)++)                                                        \
-               for_each_if (connector)
-#else
-#define nv_drm_for_each_connector_in_state(__state,                         \
-                                           connector, connector_state, __i) \
-    for_each_connector_in_state(__state, connector, connector_state, __i)
-#endif
-
-
-/**
- * nv_drm_for_each_crtc_in_state - iterate over all CRTCs in an atomic update
- * @__state: &struct drm_atomic_state pointer
- * @crtc: &struct drm_crtc iteration cursor
- * @crtc_state: &struct drm_crtc_state iteration cursor
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all CRTCs in an atomic update. Note that before the
- * software state is committed (by calling drm_atomic_helper_swap_state(), this
- * points to the new state, while afterwards it points to the old state. Due to
- * this tricky confusion this macro is deprecated.
- */
-#if !defined(for_each_crtc_in_state)
-#define nv_drm_for_each_crtc_in_state(__state, crtc, crtc_state, __i) \
-       for ((__i) = 0;                                                \
-            (__i) < (__state)->dev->mode_config.num_crtc &&           \
-            ((crtc) = (__state)->crtcs[__i].ptr,                      \
-            (crtc_state) = (__state)->crtcs[__i].state, 1);           \
-            (__i)++)                                                  \
-               for_each_if (crtc_state)
-#else
-#define nv_drm_for_each_crtc_in_state(__state, crtc, crtc_state, __i) \
-    for_each_crtc_in_state(__state, crtc, crtc_state, __i)
-#endif
-
-/**
- * nv_drm_for_each_plane_in_state - iterate over all planes in an atomic update
- * @__state: &struct drm_atomic_state pointer
- * @plane: &struct drm_plane iteration cursor
- * @plane_state: &struct drm_plane_state iteration cursor
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all planes in an atomic update. Note that before the
- * software state is committed (by calling drm_atomic_helper_swap_state(), this
- * points to the new state, while afterwards it points to the old state. Due to
- * this tricky confusion this macro is deprecated.
- */
-#if !defined(for_each_plane_in_state)
-#define nv_drm_for_each_plane_in_state(__state, plane, plane_state, __i) \
-       for ((__i) = 0;                                                   \
-            (__i) < (__state)->dev->mode_config.num_total_plane &&       \
-            ((plane) = (__state)->planes[__i].ptr,                       \
-            (plane_state) = (__state)->planes[__i].state, 1);            \
-            (__i)++)                                                     \
-               for_each_if (plane_state)
-#else
-#define nv_drm_for_each_plane_in_state(__state, plane, plane_state, __i) \
-    for_each_plane_in_state(__state, plane, plane_state, __i)
-#endif
-
-/*
- * for_each_new_plane_in_state() was added by kernel commit
- * 581e49fe6b411f407102a7f2377648849e0fa37f which was Signed-off-by:
- *      Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
- *      Daniel Vetter <daniel.vetter@ffwll.ch>
- *
- * This commit also added the old_state and new_state pointers to
- * __drm_planes_state. Because of this, the best that can be done on kernel
- * versions without this macro is for_each_plane_in_state.
- */
-
-/**
- * nv_drm_for_each_new_plane_in_state - iterate over all planes in an atomic update
- * @__state: &struct drm_atomic_state pointer
- * @plane: &struct drm_plane iteration cursor
- * @new_plane_state: &struct drm_plane_state iteration cursor for the new state
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all planes in an atomic update, tracking only the new
- * state. This is useful in enable functions, where we need the new state the
- * hardware should be in when the atomic commit operation has completed.
- */
-#if !defined(for_each_new_plane_in_state)
-#define nv_drm_for_each_new_plane_in_state(__state, plane, new_plane_state, __i) \
-    nv_drm_for_each_plane_in_state(__state, plane, new_plane_state, __i)
-#else
-#define nv_drm_for_each_new_plane_in_state(__state, plane, new_plane_state, __i) \
-    for_each_new_plane_in_state(__state, plane, new_plane_state, __i)
-#endif
-
 #include <drm/drm_auth.h>
 #include <drm/drm_file.h>
 
diff -rupN a/nvidia-drm/nvidia-drm-modeset.c b/nvidia-drm/nvidia-drm-modeset.c
--- a/nvidia-drm/nvidia-drm-modeset.c	2025-11-21 14:03:12.000000000 +0100
+++ b/nvidia-drm/nvidia-drm-modeset.c	2025-12-08 13:50:03.000000000 +0100
@@ -108,8 +108,11 @@ static bool __will_generate_flip_event(s
         return false;
     }
 
-    /* Find out whether primary & overlay flip done events will be generated. */
-    nv_drm_for_each_plane_in_state(old_crtc_state->state,
+    /*
+     * Find out whether primary & overlay flip done events will be generated.
+     * Only called after drm_atomic_helper_swap_state, so we use old state.
+     */
+    for_each_old_plane_in_state(old_crtc_state->state,
         plane, old_plane_state, i) {
         if (old_plane_state->crtc != crtc) {
            continue;
@@ -193,7 +196,7 @@ static int __nv_drm_convert_in_fences(
         return 0;
     }
 
-    nv_drm_for_each_new_plane_in_state(state, plane, plane_state, i) {
+    for_each_new_plane_in_state(state, plane, plane_state, i) {
         if ((plane->type == DRM_PLANE_TYPE_CURSOR) ||
             (plane_state->crtc != crtc) ||
             (plane_state->fence == NULL)) {
@@ -334,7 +337,8 @@ static int __nv_drm_get_syncpt_data(
 
     head_reply_config = &reply_config->headReplyConfig[nv_crtc->head];
 
-    nv_drm_for_each_plane_in_state(old_crtc_state->state, plane, old_plane_state, i) {
+    /* Use old state because this is only called after drm_atomic_helper_swap_state */
+    for_each_old_plane_in_state(old_crtc_state->state, plane, old_plane_state, i) {
         struct nv_drm_plane *nv_plane = to_nv_plane(plane);
 
         if (plane->type == DRM_PLANE_TYPE_CURSOR || old_plane_state->crtc != crtc) {
@@ -395,7 +399,7 @@ nv_drm_atomic_apply_modeset_config(struc
         &(to_nv_atomic_state(state)->config);
     struct NvKmsKapiModeSetReplyConfig reply_config = { };
     struct drm_crtc *crtc;
-    struct drm_crtc_state *crtc_state;
+    struct drm_crtc_state *old_crtc_state, *new_crtc_state;
     int i;
     int ret;
 
@@ -429,18 +433,10 @@ nv_drm_atomic_apply_modeset_config(struc
     memset(requested_config, 0, sizeof(*requested_config));
 
     /* Loop over affected crtcs and construct NvKmsKapiRequestedModeSetConfig */
-    nv_drm_for_each_crtc_in_state(state, crtc, crtc_state, i) {
-        /*
-         * When committing a state, the new state is already stored in
-         * crtc->state. When checking a proposed state, the proposed state is
-         * stored in crtc_state.
-         */
-        struct drm_crtc_state *new_crtc_state =
-                               commit ? crtc->state : crtc_state;
+    for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {
         struct nv_drm_crtc *nv_crtc = to_nv_crtc(crtc);
 
         if (commit) {
-            struct drm_crtc_state *old_crtc_state = crtc_state;
             struct nv_drm_crtc_state *nv_new_crtc_state =
                 to_nv_crtc_state(new_crtc_state);
 
@@ -497,10 +493,11 @@ nv_drm_atomic_apply_modeset_config(struc
     }
 
     if (commit && nv_dev->supportsSyncpts) {
-        nv_drm_for_each_crtc_in_state(state, crtc, crtc_state, i) {
+        /* commit is true so we check old state */
+        for_each_old_crtc_in_state(state, crtc, old_crtc_state, i) {
             /*! loop over affected crtcs and get NvKmsKapiModeSetReplyConfig */
             ret = __nv_drm_get_syncpt_data(
-                      nv_dev, crtc, crtc_state, requested_config, &reply_config);
+                      nv_dev, crtc, old_crtc_state, requested_config, &reply_config);
             if (ret != 0) {
                 return ret;
             }
@@ -525,7 +522,7 @@ int nv_drm_atomic_check(struct drm_devic
     bool cursor_surface_changed;
     bool cursor_only_commit;
 
-    nv_drm_for_each_crtc_in_state(state, crtc, crtc_state, i) {
+    for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
 
         /*
          * Committing cursor surface change without any other plane change can
@@ -534,7 +531,7 @@ int nv_drm_atomic_check(struct drm_devic
          */
         cursor_surface_changed = false;
         cursor_only_commit = true;
-        nv_drm_for_each_plane_in_state(crtc_state->state, plane, plane_state, j) {
+        for_each_new_plane_in_state(crtc_state->state, plane, plane_state, j) {
             if (plane->type == DRM_PLANE_TYPE_CURSOR) {
                 if (plane_state->fb != plane->state->fb) {
                     cursor_surface_changed = true;
@@ -641,7 +638,7 @@ int nv_drm_atomic_commit(struct drm_devi
      * Our system already implements such a queue, but due to
      * bug 4054608, it is currently not used.
      */
-    nv_drm_for_each_crtc_in_state(state, crtc, crtc_state, i) {
+    for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
         struct nv_drm_crtc *nv_crtc = to_nv_crtc(crtc);
 
         /*
@@ -748,7 +745,7 @@ int nv_drm_atomic_commit(struct drm_devi
         goto done;
     }
 
-    nv_drm_for_each_crtc_in_state(state, crtc, crtc_state, i) {
+    for_each_old_crtc_in_state(state, crtc, crtc_state, i) {
         struct nv_drm_crtc *nv_crtc = to_nv_crtc(crtc);
         struct nv_drm_crtc_state *nv_new_crtc_state =
             to_nv_crtc_state(crtc->state);
diff -rupN a/nvidia-drm/nvidia-drm-priv.h b/nvidia-drm/nvidia-drm-priv.h
--- a/nvidia-drm/nvidia-drm-priv.h	2025-11-21 14:03:09.000000000 +0100
+++ b/nvidia-drm/nvidia-drm-priv.h	2025-12-08 13:49:59.000000000 +0100
@@ -30,6 +30,7 @@
 #if defined(NV_DRM_DRMP_H_PRESENT)
 #include <drm/drmP.h>
 #endif
+#include <drm/drm_print.h>
 
 #include <drm/drm_device.h>
 #include <drm/drm_gem.h>
diff -rupN a/nvidia-drm/nvidia-drm-sources.mk b/nvidia-drm/nvidia-drm-sources.mk
--- a/nvidia-drm/nvidia-drm-sources.mk	2025-11-21 13:40:42.000000000 +0100
+++ b/nvidia-drm/nvidia-drm-sources.mk	2025-12-08 13:28:04.000000000 +0100
@@ -64,6 +64,7 @@ NV_CONFTEST_FUNCTION_COMPILE_TESTS += vm
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_gem_prime_mmap
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_sysfs_connector_property_event
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_sysfs_connector_status_event
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += vm_flags_set
 
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_has_legacy_dev_list
 NV_CONFTEST_TYPE_COMPILE_TESTS += vm_ops_fault_removed_vma_arg
@@ -93,7 +94,6 @@ NV_CONFTEST_TYPE_COMPILE_TESTS += reserv
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_connector_has_override_edid
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_file_get_master
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_modeset_lock_all_end
-NV_CONFTEST_TYPE_COMPILE_TESTS += vm_area_struct_has_const_vm_flags
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_has_dumb_destroy
 NV_CONFTEST_TYPE_COMPILE_TESTS += fence_ops_use_64bit_seqno
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_aperture_remove_conflicting_framebuffers_has_driver_arg
Binary files a/nvidia-modeset/nv-modeset-kernel.o_binary and b/nvidia-modeset/nv-modeset-kernel.o_binary differ
diff -rupN a/nvidia-uvm/uvm_migrate_pageable.c b/nvidia-uvm/uvm_migrate_pageable.c
--- a/nvidia-uvm/uvm_migrate_pageable.c	2025-11-21 14:44:24.000000000 +0100
+++ b/nvidia-uvm/uvm_migrate_pageable.c	2025-12-08 14:44:53.000000000 +0100
@@ -43,8 +43,6 @@
 
 #ifdef UVM_MIGRATE_VMA_SUPPORTED
 
-static struct kmem_cache *g_uvm_migrate_vma_state_cache __read_mostly;
-
 static const gfp_t g_migrate_vma_gfp_flags = NV_UVM_GFP_FLAGS | GFP_HIGHUSER_MOVABLE | __GFP_THISNODE;
 
 static uvm_sgt_t *uvm_select_sgt(uvm_processor_id_t src_id, int src_nid, migrate_vma_state_t *state)
@@ -1497,7 +1495,7 @@ NV_STATUS uvm_migrate_pageable(uvm_migra
         uvm_migrate_args->dst_node_id = uvm_gpu_numa_node(gpu);
     }
 
-    state = nv_kmem_cache_zalloc(g_uvm_migrate_vma_state_cache, NV_UVM_GFP_FLAGS);
+    state = uvm_kvmalloc_zero(sizeof(migrate_vma_state_t));
     if (!state)
         return NV_ERR_NO_MEMORY;
 
@@ -1519,22 +1517,17 @@ NV_STATUS uvm_migrate_pageable(uvm_migra
 out:
     uvm_kvfree(state->dma.sgt_cpu);
     uvm_kvfree(state->cpu_page_mask);
-    kmem_cache_free(g_uvm_migrate_vma_state_cache, state);
+    uvm_kvfree(state);
 
     return status;
 }
 
 NV_STATUS uvm_migrate_pageable_init(void)
 {
-    g_uvm_migrate_vma_state_cache = NV_KMEM_CACHE_CREATE("migrate_vma_state_t", migrate_vma_state_t);
-    if (!g_uvm_migrate_vma_state_cache)
-        return NV_ERR_NO_MEMORY;
-
     return NV_OK;
 }
 
 void uvm_migrate_pageable_exit(void)
 {
-    kmem_cache_destroy_safe(&g_uvm_migrate_vma_state_cache);
 }
 #endif
diff -rupN a/patches/compile_fix_6.19.patch b/patches/compile_fix_6.19.patch
--- a/patches/compile_fix_6.19.patch	2025-12-18 17:18:08.872622913 +0100
+++ b/patches/compile_fix_6.19.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,196 +0,0 @@
-diff -rupN a/common/inc/nv-memdbg.h b/common/inc/nv-memdbg.h
---- a/common/inc/nv-memdbg.h	2025-11-21 14:44:37.000000000 +0100
-+++ b/common/inc/nv-memdbg.h	2025-12-18 17:11:24.244526046 +0100
-@@ -41,8 +41,8 @@ void nv_memdbg_exit(void);
- 
- #else
- 
--#define NV_MEMDBG_ADD(ptr, size)
--#define NV_MEMDBG_REMOVE(ptr, size)
-+#define NV_MEMDBG_ADD(ptr, size) while(0)
-+#define NV_MEMDBG_REMOVE(ptr, size) while(0)
- 
- #endif /* NV_MEM_LOGGER */
- 
-diff -rupN a/common/inc/nv-mm.h b/common/inc/nv-mm.h
---- a/common/inc/nv-mm.h	2025-11-21 14:44:03.000000000 +0100
-+++ b/common/inc/nv-mm.h	2025-12-18 17:11:24.244797940 +0100
-@@ -24,6 +24,7 @@
- #define __NV_MM_H__
- 
- #include "conftest.h"
-+#include <linux/version.h>
- 
- #if !defined(NV_VM_FAULT_T_IS_PRESENT)
- typedef int vm_fault_t;
-@@ -206,7 +207,11 @@ static inline void nv_vm_flags_set(struc
- {
- #if !NV_CAN_CALL_VMA_START_WRITE
-     nv_vma_start_write(vma);
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 19, 0)
-     ACCESS_PRIVATE(vma, __vm_flags) |= flags;
-+#else
-+    ACCESS_PRIVATE(&vma->flags, __vma_flags) |= flags;
-+#endif
- #elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
-     vm_flags_set(vma, flags);
- #else
-@@ -218,7 +223,11 @@ static inline void nv_vm_flags_clear(str
- {
- #if !NV_CAN_CALL_VMA_START_WRITE
-     nv_vma_start_write(vma);
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 19, 0)
-     ACCESS_PRIVATE(vma, __vm_flags) &= ~flags;
-+#else
-+    ACCESS_PRIVATE(&vma->flags, __vma_flags) &= ~flags;
-+#endif
- #elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
-     vm_flags_clear(vma, flags);
- #else
-diff -rupN a/conftest.sh b/conftest.sh
---- a/conftest.sh	2025-11-21 13:39:41.000000000 +0100
-+++ b/conftest.sh	2025-12-18 17:11:24.245164813 +0100
-@@ -215,6 +215,7 @@ build_cflags() {
-             CFLAGS="$CFLAGS -mfentry -DCC_USING_FENTRY"
-         fi
-     fi
-+    CFLAGS="$CFLAGS -fms-extensions"
- }
- 
- CONFTEST_PREAMBLE="#include \"conftest/headers.h\"
-@@ -3988,7 +3989,8 @@ compile_test() {
-             CODE="
-             #include <linux/mm_types.h>
-             int conftest_vm_area_struct_has_const_vm_flags(void) {
--                return offsetof(struct vm_area_struct, __vm_flags);
-+                struct vm_area_struct vma;
-+                return _Generic(&vma.vm_flags, const typeof(vma.vm_flags) *: 1);
-             }"
- 
-             compile_check_conftest "$CODE" "NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS" "" "types"
-diff -rupN a/nvidia/nv-dma.c b/nvidia/nv-dma.c
---- a/nvidia/nv-dma.c	2025-11-21 14:44:33.000000000 +0100
-+++ b/nvidia/nv-dma.c	2025-12-18 17:11:24.247116655 +0100
-@@ -26,6 +26,7 @@
- #include "os-interface.h"
- #include "nv-linux.h"
- #include "nv-reg.h"
-+#include <linux/version.h>
- 
- #if IS_ENABLED(CONFIG_DRM)
- #include <drm/drm_device.h>
-@@ -729,7 +730,11 @@ static NvBool nv_dma_use_map_resource
- #endif
-     }
- 
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 19, 0)
-+    return (ops->map_phys != NULL);
-+#else
-     return (ops->map_resource != NULL);
-+#endif
- }
- 
- /* DMA-map a peer device's C2C aperture for peer access. */
-diff -rupN a/nvidia/nv-imp.c b/nvidia/nv-imp.c
---- a/nvidia/nv-imp.c	2025-11-21 14:44:32.000000000 +0100
-+++ b/nvidia/nv-imp.c	2025-12-18 17:18:02.443471537 +0100
-@@ -53,13 +53,6 @@
-      IS_ENABLED(CONFIG_TEGRA_BPMP)) && \
-     defined(NV_LINUX_PLATFORM_TEGRA_MC_UTILS_H_PRESENT)
- 
--//
--// Also create a macro to check if all the required ICC symbols are present.
--// DT endpoints are defined in dt-bindings/interconnect/tegra_icc_id.h.
--//
--#define ICC_SUPPORT_FUNCTIONS_PRESENT \
--    defined(NV_DT_BINDINGS_INTERCONNECT_TEGRA_ICC_ID_H_PRESENT)
--
- /*!
-  * @brief Returns IMP-relevant data collected from other modules
-  *
-@@ -112,43 +105,6 @@ nv_imp_enable_disable_rfl
- )
- {
-     NV_STATUS status = NV_ERR_NOT_SUPPORTED;
--#if IMP_SUPPORT_FUNCTIONS_PRESENT
--#if IS_ENABLED(CONFIG_TEGRA_BPMP) && NV_SUPPORTS_PLATFORM_DEVICE
--    nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
--    struct tegra_bpmp *bpmp = tegra_bpmp_get(nvl->dev);
--    struct tegra_bpmp_message msg;
--    struct mrq_emc_disp_rfl_request emc_disp_rfl_request;
--    int rc;
--
--    memset(&emc_disp_rfl_request, 0, sizeof(emc_disp_rfl_request));
--    emc_disp_rfl_request.mode = bEnable ? EMC_DISP_RFL_MODE_ENABLED :
--                                          EMC_DISP_RFL_MODE_DISABLED;
--    msg.mrq = MRQ_EMC_DISP_RFL;
--    msg.tx.data = &emc_disp_rfl_request;
--    msg.tx.size = sizeof(emc_disp_rfl_request);
--    msg.rx.data = NULL;
--    msg.rx.size = 0;
--
--    rc = tegra_bpmp_transfer(bpmp, &msg);
--    if (rc == 0)
--    {
--        nv_printf(NV_DBG_INFO,
--                  "\"Wait for RFL\" is %s via MRQ_EMC_DISP_RFL\n",
--                  bEnable ? "enabled" : "disabled");
--        status = NV_OK;
--    }
--    else
--    {
--        nv_printf(NV_DBG_ERRORS,
--                  "MRQ_EMC_DISP_RFL failed to %s \"Wait for RFL\" (error code = %d)\n",
--                  bEnable ? "enable" : "disable",
--                  rc);
--        status = NV_ERR_GENERIC;
--    }
--#else
--    nv_printf(NV_DBG_ERRORS, "nv_imp_enable_disable_rfl stub called!\n");
--#endif
--#endif
-     return status;
- }
- 
-@@ -171,9 +127,6 @@ nv_imp_icc_get
-     nv_state_t *nv
- )
- {
--#if ICC_SUPPORT_FUNCTIONS_PRESENT && NV_SUPPORTS_PLATFORM_DEVICE
--    nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
--    NV_STATUS status = NV_OK;
- 
- #if defined(NV_DEVM_ICC_GET_PRESENT)
-     // Needs to use devm_of_icc_get function as per the latest ICC driver
-@@ -246,8 +199,6 @@ nv_imp_icc_put
-     nv_state_t *nv
- )
- {
--#if ICC_SUPPORT_FUNCTIONS_PRESENT
--    nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
- 
- #if defined(NV_DEVM_ICC_GET_PRESENT)
-     //
-@@ -305,10 +256,6 @@ nv_imp_icc_set_bw
-     NvU32       floor_bw_kbps
- )
- {
--#if ICC_SUPPORT_FUNCTIONS_PRESENT && NV_SUPPORTS_PLATFORM_DEVICE
--    nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
--    int rc;
--    NV_STATUS status = NV_OK;
-  
-     //
-     // avg_bw_kbps can be either ISO bw request or NISO bw request.
-diff -rupN a/nvidia-drm/nvidia-drm-priv.h b/nvidia-drm/nvidia-drm-priv.h
---- a/nvidia-drm/nvidia-drm-priv.h	2025-11-21 14:03:09.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-priv.h	2025-12-18 17:11:24.247465028 +0100
-@@ -33,7 +33,7 @@
- 
- #include <drm/drm_device.h>
- #include <drm/drm_gem.h>
--
-+#include <drm/drm_print.h>
- #include "nvidia-drm-os-interface.h"
- 
- #include "nvkms-kapi.h"
diff -rupN a/patches/dma.patch b/patches/dma.patch
--- a/patches/dma.patch	2025-12-07 16:47:38.276585538 +0100
+++ b/patches/dma.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-diff -rupN a/nvidia/nv-dma.c b/nvidia/nv-dma.c
---- a/nvidia/nv-dma.c   2025-09-23 12:33:36.000000000 +0200
-+++ b/nvidia/nv-dma.c   2025-10-30 09:45:45.633887286 +0100
-@@ -718,7 +718,7 @@ static NvBool nv_dma_use_map_resource
- #endif
-     }
- 
--    return (ops->map_resource != NULL);
-+    return NV_TRUE;
- }
- 
- /* DMA-map a peer device's C2C aperture for peer access. */
diff -rupN a/patches/drm_error.patch b/patches/drm_error.patch
--- a/patches/drm_error.patch	2025-12-07 16:58:17.575582294 +0100
+++ b/patches/drm_error.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-diff -rupN a/nvidia-drm/nvidia-drm-priv.h b/nvidia-drm/nvidia-drm-priv.h
---- a/nvidia-drm/nvidia-drm-priv.h      2025-11-21 14:03:09.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-priv.h      2025-12-07 16:57:46.703308169 +0100
-@@ -33,19 +33,20 @@
- 
- #include <drm/drm_device.h>
- #include <drm/drm_gem.h>
-+#include <drm/drm_print.h>
- 
- #include "nvidia-drm-os-interface.h"
- 
- #include "nvkms-kapi.h"
- 
- #define NV_DRM_LOG_ERR(__fmt, ...) \
--    DRM_ERROR("[nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
-+    drm_err("[nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
- 
- /*
-  * DRM_WARN() was added in v4.9 by kernel commit
-  * 30b0da8d556e65ff935a56cd82c05ba0516d3e4a
-  *
-- * Before this commit, only DRM_INFO and DRM_ERROR were defined and
-+ * Before this commit, only DRM_INFO and drm_err were defined and
-  * DRM_INFO(fmt, ...) was defined as
-  * printk(KERN_INFO "[" DRM_NAME "] " fmt, ##__VA_ARGS__). So, if
-  * DRM_WARN is undefined this defines NV_DRM_LOG_WARN following the
diff -rupN a/patches/in_irq.patch b/patches/in_irq.patch
--- a/patches/in_irq.patch	2025-12-07 15:37:57.959380315 +0100
+++ b/patches/in_irq.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-diff -rupN a/common/inc/nv-time.h b/common/inc/nv-time.h
---- a/common/inc/nv-time.h	2025-09-23 12:32:58.000000000 +0200
-+++ b/common/inc/nv-time.h	2025-10-26 13:29:54.672534572 +0100
-@@ -82,7 +82,7 @@ static inline NV_STATUS nv_sleep_us(unsi
-     ktime_get_raw_ts64(&tm1);
- #endif
- 
--    if (in_irq() && (us > NV_MAX_ISR_DELAY_US))
-+    if (in_hardirq() && (us > NV_MAX_ISR_DELAY_US))
-         return NV_ERR_GENERIC;
- 
-     mdelay_safe_msec = us / 1000;
-@@ -127,7 +127,7 @@ static inline NV_STATUS nv_sleep_ms(unsi
-     tm_start = tm_aux;
- #endif
- 
--    if (in_irq() && (ms > NV_MAX_ISR_DELAY_MS))
-+    if (in_hardirq() && (ms > NV_MAX_ISR_DELAY_MS))
-     {
-         return NV_ERR_GENERIC;
-     }
-diff -rupN a/nvidia/os-interface.c b/nvidia/os-interface.c
---- a/nvidia/os-interface.c	2025-09-23 12:33:36.000000000 +0200
-+++ b/nvidia/os-interface.c	2025-10-26 13:30:15.984579282 +0100
-@@ -341,7 +341,7 @@ NvBool NV_API_CALL os_semaphore_may_slee
- 
- NvBool NV_API_CALL os_is_isr(void)
- {
--    return (in_irq());
-+    return (in_hardirq());
- }
- 
- // return TRUE if the caller is the super-user
diff -rupN a/patches/OLD/drm_error.patch.test b/patches/OLD/drm_error.patch.test
--- a/patches/OLD/drm_error.patch.test	2025-12-18 14:49:26.228681518 +0100
+++ b/patches/OLD/drm_error.patch.test	1970-01-01 01:00:00.000000000 +0100
@@ -1,1055 +0,0 @@
-diff -rupN a/nvidia-drm/nvidia-drm.c b/nvidia-drm/nvidia-drm.c
---- a/nvidia-drm/nvidia-drm.c	2025-11-21 14:03:08.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm.c	2025-12-18 14:23:03.151361107 +0100
-@@ -45,9 +45,6 @@ int nv_drm_init(void)
- {
- #if defined(NV_DRM_AVAILABLE)
-     if (!nvKmsKapiGetFunctionsTable(&nvKmsFuncsTable)) {
--        NV_DRM_LOG_ERR(
--            "Version mismatch: nvidia-modeset.ko(%s) nvidia-drm.ko(%s)",
--            nvKmsFuncsTable.versionString, NV_VERSION_STRING);
-         return -EINVAL;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-connector.c b/nvidia-drm/nvidia-drm-connector.c
---- a/nvidia-drm/nvidia-drm-connector.c	2025-11-21 14:03:11.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-connector.c	2025-12-18 14:36:36.285293586 +0100
-@@ -118,9 +118,6 @@ __nv_drm_detect_encoder(struct NvKmsKapi
-     }
- 
-     if (!nvKms->getDynamicDisplayInfo(nv_dev->pDevice, pDetectParams)) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to detect display state");
-         return false;
-     }
- 
-@@ -139,8 +136,6 @@ __nv_drm_detect_encoder(struct NvKmsKapi
-                 memcpy(nv_connector->edid,
-                        pDetectParams->edid.buffer,
-                        pDetectParams->edid.bufferSize);
--            } else {
--                NV_DRM_LOG_ERR("Out of Memory");
-             }
-         }
- 
-@@ -265,10 +260,6 @@ static int nv_drm_connector_get_modes(st
-                                     &preferredMode);
- 
-         if (ret < 0) {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to get mode at modeIndex %d of NvKmsKapiDisplay 0x%08x",
--                modeIndex, nv_detected_encoder->hDisplay);
-             break;
-         }
- 
-@@ -287,10 +278,6 @@ static int nv_drm_connector_get_modes(st
-         mode = drm_mode_create(connector->dev);
- 
-         if (mode == NULL) {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to create mode for NvKmsKapiDisplay 0x%08x",
--                nv_detected_encoder->hDisplay);
-             continue;
-         }
- 
-@@ -462,7 +449,6 @@ __nv_drm_connector_atomic_check(struct d
-             break;
-         default:
-             // XXX HDR TODO: Add support for more color spaces
--            NV_DRM_DEV_LOG_ERR(nv_dev, "Unsupported color space");
-             return -EINVAL;
-     }
- 
-@@ -513,10 +499,6 @@ nv_drm_connector_new(struct drm_device *
-         nvkms_connector_type_to_drm_connector_type(type, internal));
- 
-     if (ret != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to initialize connector created from physical index %u",
--            nv_connector->physicalIndex);
-         goto failed_connector_init;
-     }
- 
-@@ -560,10 +542,6 @@ nv_drm_connector_new(struct drm_device *
-     ret = drm_connector_register(&nv_connector->base);
- 
-     if (ret != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to register connector created from physical index %u",
--            nv_connector->physicalIndex);
-         goto failed_connector_register;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-crtc.c b/nvidia-drm/nvidia-drm-crtc.c
---- a/nvidia-drm/nvidia-drm-crtc.c	2025-11-21 14:03:11.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-crtc.c	2025-12-18 14:36:10.286033341 +0100
-@@ -1330,7 +1330,6 @@ plane_req_config_update(struct drm_plane
-         uint32_t i;
- 
-         if (hdr_metadata->metadata_type != HDMI_STATIC_METADATA_TYPE1) {
--            NV_DRM_DEV_LOG_ERR(nv_dev, "Unsupported Metadata Type");
-             return -1;
-         }
- 
-@@ -1363,7 +1362,6 @@ plane_req_config_update(struct drm_plane
-                     NVKMS_OUTPUT_TF_TRADITIONAL_GAMMA_SDR;
-                 break;
-             default:
--                NV_DRM_DEV_LOG_ERR(nv_dev, "Unsupported EOTF");
-                 return -1;
-         }
- 
-@@ -2923,9 +2921,6 @@ static struct drm_crtc *__nv_drm_crtc_cr
-                                     &nv_crtc_funcs,
-                                     NULL);
-     if (ret != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to init crtc for head %u with planes", head);
-         goto failed_init_crtc;
-     }
- 
-@@ -2980,10 +2975,6 @@ void nv_drm_enumerate_crtcs_and_planes(
-                                 pResInfo);
- 
-         if (IS_ERR(primary_plane)) {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to create primary plane for head %u, error = %ld",
--                i, PTR_ERR(primary_plane));
-             continue;
-         }
- 
-@@ -2994,10 +2985,6 @@ void nv_drm_enumerate_crtcs_and_planes(
-                                 i,
-                                 pResInfo);
-         if (IS_ERR(cursor_plane)) {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to create cursor plane for head %u, error = %ld",
--                i, PTR_ERR(cursor_plane));
-             cursor_plane = NULL;
-         }
- 
-@@ -3014,10 +3001,6 @@ void nv_drm_enumerate_crtcs_and_planes(
-                     nv_drm_plane_destroy(cursor_plane);
-                 }
- 
--                NV_DRM_DEV_LOG_ERR(
--                    nv_dev,
--                    "Failed to add DRM CRTC for head %u, error = %ld",
--                    i, PTR_ERR(crtc));
-                 continue;
-             }
-         }
-@@ -3035,13 +3018,6 @@ void nv_drm_enumerate_crtcs_and_planes(
-                                     layer,
-                                     i,
-                                     pResInfo);
--
--            if (IS_ERR(overlay_plane)) {
--                NV_DRM_DEV_LOG_ERR(
--                    nv_dev,
--                    "Failed to create plane for layer-%u of head %u, error = %ld",
--                    layer, i, PTR_ERR(overlay_plane));
--            }
-         }
- 
-     }
-diff -rupN a/nvidia-drm/nvidia-drm-drv.c b/nvidia-drm/nvidia-drm-drv.c
---- a/nvidia-drm/nvidia-drm-drv.c	2025-11-21 14:03:11.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-drv.c	2025-12-18 14:35:33.685666989 +0100
-@@ -411,22 +411,12 @@ static void nv_drm_enumerate_encoders_an
-     struct drm_device *dev = nv_dev->dev;
-     NvU32 nDisplays = 0;
- 
--    if (!nvKms->getDisplays(nv_dev->pDevice, &nDisplays, NULL)) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to enumurate NvKmsKapiDisplay count");
--    }
--
-     if (nDisplays != 0) {
-         NvKmsKapiDisplay *hDisplays =
-             nv_drm_calloc(nDisplays, sizeof(*hDisplays));
- 
-         if (hDisplays != NULL) {
--            if (!nvKms->getDisplays(nv_dev->pDevice, &nDisplays, hDisplays)) {
--                NV_DRM_DEV_LOG_ERR(
--                    nv_dev,
--                    "Failed to enumurate NvKmsKapiDisplay handles");
--            } else {
-+            if (nvKms->getDisplays(nv_dev->pDevice, &nDisplays, hDisplays)) {
-                 NvU32 i, j;
-                 NvU32 nDynamicDisplays = 0;
- 
-@@ -435,19 +425,7 @@ static void nv_drm_enumerate_encoders_an
-                     struct drm_encoder *encoder =
-                         nv_drm_add_encoder(dev, hDisplays[i]);
- 
--                    if (IS_ERR(encoder)) {
--                        NV_DRM_DEV_LOG_ERR(
--                            nv_dev,
--                            "Failed to add connector for NvKmsKapiDisplay 0x%08x",
--                            hDisplays[i]);
--                    }
--
--                    if (nv_drm_get_mst_display_infos(nv_dev, hDisplays[i],
--                            &displayInfos, &nDynamicDisplays)) {
--                        NV_DRM_DEV_LOG_ERR(
--                                nv_dev,
--                                "Failed to get dynamic displays");
--                    } else if (nDynamicDisplays) {
-+                    if (nDynamicDisplays) {
-                         nv_drm_sort_dynamic_displays_by_dp_addr(displayInfos, nDynamicDisplays);
- 
-                         for (j = 0; j < nDynamicDisplays; j++) {
-@@ -458,12 +436,6 @@ static void nv_drm_enumerate_encoders_an
-                                 NV_DRM_DEV_DEBUG_DRIVER(nv_dev, "found DP MST port display handle %u",
-                                         displayInfos[j].handle);
- 
--                                if (IS_ERR(mst_encoder)) {
--                                    NV_DRM_DEV_LOG_ERR(
--                                            nv_dev,
--                                            "Failed to add connector for NvKmsKapiDisplay 0x%08x",
--                                            displayInfos[j].handle);
--                                }
-                             }
-                         }
- 
-@@ -473,10 +445,6 @@ static void nv_drm_enumerate_encoders_an
-             }
- 
-             nv_drm_free(hDisplays);
--        } else {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to allocate memory for NvKmsKapiDisplay array");
-         }
-     }
- }
-@@ -522,7 +490,6 @@ static int nv_drm_create_properties(stru
-         drm_property_create_enum(nv_dev->dev, 0, "NV_INPUT_COLORSPACE",
-                                  colorspace_enum_list, len);
-     if (nv_dev->nv_input_colorspace_property == NULL) {
--        NV_DRM_LOG_ERR("Failed to create NV_INPUT_COLORSPACE property");
-         return -ENOMEM;
-     }
- 
-@@ -699,8 +666,6 @@ static int nv_drm_dev_load(struct drm_de
-              * producing a scary-looking error.
-              */
-             NV_DRM_DEV_LOG_INFO(nv_dev, "NUMA was not set up yet; ignoring this device");
--        } else {
--            NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to allocate NvKmsKapiDevice");
-         }
-         return -ENODEV;
-     }
-@@ -711,9 +676,6 @@ static int nv_drm_dev_load(struct drm_de
- 
-         nvKms->freeDevice(pDevice);
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to query NvKmsKapiDevice resources info");
-         return -ENODEV;
-     }
- 
-@@ -725,7 +687,6 @@ static int nv_drm_dev_load(struct drm_de
-     if (nv_drm_fbdev_module_param) {
-         if (!nvKms->grabOwnership(pDevice)) {
-             nvKms->freeDevice(pDevice);
--            NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to grab NVKMS modeset ownership");
-             return -EBUSY;
-         }
- 
-@@ -797,18 +758,9 @@ static int nv_drm_dev_load(struct drm_de
-         }
- #endif
-         nvKms->freeDevice(nv_dev->pDevice);
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to create DRM properties");
-         return -ENODEV;
-     }
- 
--    if (!nvKms->declareEventInterest(
--            nv_dev->pDevice,
--            ((1 << NVKMS_EVENT_TYPE_DPY_CHANGED) |
--             (1 << NVKMS_EVENT_TYPE_DYNAMIC_DPY_CONNECTED) |
--             (1 << NVKMS_EVENT_TYPE_FLIP_OCCURRED)))) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to register event mask");
--    }
--
-     /* Add crtcs */
- 
-     nv_drm_enumerate_crtcs_and_planes(nv_dev, &resInfo);
-@@ -878,10 +830,6 @@ static void nv_drm_dev_unload(struct drm
- 
-     drm_mode_config_cleanup(dev);
- 
--    if (!nvKms->declareEventInterest(nv_dev->pDevice, 0x0)) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to stop event listening");
--    }
--
-     /* Unset NvKmsKapiDevice */
- 
-     pDevice = nv_dev->pDevice;
-@@ -919,9 +867,6 @@ static int nv_drm_master_set(struct drm_
- static void nv_drm_master_set(struct drm_device *dev,
-                               struct drm_file *file_priv, bool from_open)
- {
--    if (__nv_drm_master_set(dev, file_priv, from_open) != 0) {
--        NV_DRM_DEV_LOG_ERR(to_nv_device(dev), "Failed to grab modeset ownership");
--    }
- }
- #endif
- 
-@@ -1002,10 +947,6 @@ void nv_drm_master_drop(struct drm_devic
-                 dev,
-                 dev->mode_config.acquire_ctx)) != 0) {
- 
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "nv_drm_atomic_helper_disable_all failed with error code %d !",
--                err);
-         }
- 
-         drm_modeset_unlock_all(dev);
-@@ -1336,12 +1277,6 @@ static int nv_drm_grant_sub_ownership(st
-      * notifications.
-      */
-     ret = nv_drm_atomic_helper_disable_all(dev, pctx);
--    if (ret != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "nv_drm_atomic_helper_disable_all failed with error code %d!",
--            ret);
--    }
- 
-     atomic_set(&nv_dev->enable_event_handling, false);
-     nv_dev->subOwnershipGranted = NV_TRUE;
-@@ -1488,7 +1423,6 @@ static int nv_drm_revoke_sub_ownership(s
-     }
- 
-     if (!nvKms->revokeSubOwnership(nv_dev->pDevice)) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to revoke sub-ownership from NVKMS");
-         goto done;
-     }
- 
-@@ -1975,8 +1909,6 @@ void nv_drm_register_drm_device(const st
-     nv_dev = nv_drm_calloc(1, sizeof(*nv_dev));
- 
-     if (nv_dev == NULL) {
--        NV_DRM_LOG_ERR(
--            "Failed to allocate memory for NVIDIA-DRM device object");
-         return;
-     }
- 
-@@ -1990,7 +1922,6 @@ void nv_drm_register_drm_device(const st
-     dev = drm_dev_alloc(&nv_drm_driver, device);
- 
-     if (dev == NULL) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to allocate device");
-         goto failed_drm_alloc;
-     }
- 
-@@ -2018,7 +1949,6 @@ void nv_drm_register_drm_device(const st
-     /* Register DRM device to DRM sub-system */
- 
-     if (drm_dev_register(dev, 0) != 0) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Failed to register device");
-         goto failed_drm_register;
-     }
- 
-@@ -2108,10 +2038,6 @@ int nv_drm_probe_devices(void)
-     /* Register DRM device for each NVIDIA GPU available via NVKMS. */
-     gpu_count = nvKms->enumerateGpus(nv_drm_register_drm_device);
- 
--    if (gpu_count == 0) {
--        NV_DRM_LOG_INFO("No NVIDIA GPUs found");
--    }
--
-     return 0;
- }
- #endif
-diff -rupN a/nvidia-drm/nvidia-drm-encoder.c b/nvidia-drm/nvidia-drm-encoder.c
---- a/nvidia-drm/nvidia-drm-encoder.c	2025-11-21 14:03:11.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-encoder.c	2025-12-18 14:33:08.611697757 +0100
-@@ -127,9 +127,6 @@ nv_drm_encoder_new(struct drm_device *de
-     nv_encoder = nv_drm_calloc(1, sizeof(*nv_encoder));
- 
-     if (nv_encoder == NULL) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate memory for NVIDIA-DRM encoder object");
-         return ERR_PTR(-ENOMEM);
-     }
- 
-@@ -144,10 +141,6 @@ nv_drm_encoder_new(struct drm_device *de
-     if (ret != 0) {
-         nv_drm_free(nv_encoder);
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to initialize encoder created from NvKmsKapiDisplay 0x%08x",
--            hDisplay);
-         return ERR_PTR(ret);
-     }
- 
-@@ -226,11 +219,6 @@ nv_drm_add_encoder(struct drm_device *de
-     ret = nv_drm_connector_attach_encoder(connector, encoder);
- 
-     if (ret != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to attach encoder created from NvKmsKapiDisplay 0x%08x "
--            "to connector",
--            hDisplay);
-         goto failed_connector_encoder_attach;
-     }
- 
-@@ -325,10 +313,6 @@ void nv_drm_handle_dynamic_display_conne
-     encoder = nv_drm_add_encoder(dev, hDisplay);
- 
-     if (IS_ERR(encoder)) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to add encoder for NvKmsKapiDisplay 0x%08x",
--            hDisplay);
-         return;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-fb.c b/nvidia-drm/nvidia-drm-fb.c
---- a/nvidia-drm/nvidia-drm-fb.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-fb.c	2025-12-18 14:32:51.483255844 +0100
-@@ -176,9 +176,6 @@ static int nv_drm_framebuffer_init(struc
-         // 'c', the lossless compression field of the modifier
-         if (params.layout == NvKmsSurfaceMemoryLayoutBlockLinear &&
-             (modifier >> 23) & 0x7) {
--            NV_DRM_DEV_LOG_ERR(
--                    nv_dev,
--                    "Cannot create FB from compressible surface allocation");
-             goto fail;
-         }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-fence.c b/nvidia-drm/nvidia-drm-fence.c
---- a/nvidia-drm/nvidia-drm-fence.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-fence.c	2025-12-18 14:32:38.211591674 +0100
-@@ -257,10 +257,6 @@ __nv_drm_prime_fence_context_new(
-                                       p->import_mem_nvkms_params_ptr,
-                                       p->import_mem_nvkms_params_size);
-     if (!pSemSurface) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to import fence semaphore surface");
--
-         goto failed;
-     }
- 
-@@ -268,10 +264,6 @@ __nv_drm_prime_fence_context_new(
-                           pSemSurface,
-                           NVKMS_KAPI_MAPPING_TYPE_KERNEL,
-                           (void **) &pLinearAddress)) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to map fence semaphore surface");
--
-         goto failed_to_map_memory;
-     }
- 
-@@ -317,8 +309,6 @@ __nv_drm_prime_fence_context_new(
-                                     p->event_nvkms_params_ptr,
-                                     p->event_nvkms_params_size);
-     if (!nv_prime_fence_context->cb) {
--        NV_DRM_DEV_LOG_ERR(nv_dev,
--                           "Failed to allocate fence signaling event");
-         goto failed_to_allocate_channel_event;
-     }
- 
-@@ -503,8 +493,6 @@ static int __nv_drm_gem_attach_fence(str
-         } else {
-             nv_dma_resv_add_excl_fence(resv, fence);
-         }
--    } else {
--        NV_DRM_LOG_ERR("Failed to reserve fence. Error code: %d", ret);
-     }
- 
-     nv_dma_resv_unlock(resv);
-@@ -529,18 +517,12 @@ int nv_drm_gem_prime_fence_attach_ioctl(
-     }
- 
-     if (p->__pad != 0) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Padding fields must be zeroed");
-         goto done;
-     }
- 
-     nv_gem = nv_drm_gem_object_lookup(filep, p->handle);
- 
-     if (!nv_gem) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for fence attach: 0x%08x",
--            p->handle);
--
-         goto done;
-     }
- 
-@@ -548,22 +530,12 @@ int nv_drm_gem_prime_fence_attach_ioctl(
-                 filep,
-                 p->fence_context_handle)) == NULL) {
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for fence context: 0x%08x",
--            p->fence_context_handle);
--
-         goto fence_context_lookup_failed;
-     }
- 
-     if (nv_fence_context->ops !=
-         &nv_drm_prime_fence_context_ops) {
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Wrong fence context type: 0x%08x",
--            p->fence_context_handle);
--
-         goto fence_context_create_fence_failed;
-     }
- 
-@@ -574,10 +546,6 @@ int nv_drm_gem_prime_fence_attach_ioctl(
-     if (IS_ERR(fence)) {
-         ret = PTR_ERR(fence);
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate fence: 0x%08x", p->handle);
--
-         goto fence_context_create_fence_failed;
-     }
- 
-@@ -1008,9 +976,6 @@ __nv_drm_semsurf_ctx_reg_callbacks(struc
-     NvKmsKapiRegisterWaiterResult kapiRet;
- 
-     if (!newCallback) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate new fence signal callback data");
-         return;
-     }
- 
-@@ -1239,10 +1204,6 @@ __nv_drm_semsurf_fence_ctx_new(
-                                                 (void **)&semMapping,
-                                                 (void **)&maxSubmittedMapping);
-     if (!pSemSurface) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to import semaphore surface");
--
-         goto failed;
-     }
- 
-@@ -1319,7 +1280,6 @@ int nv_drm_semsurf_fence_ctx_create_ioct
-     }
- 
-     if (p->__pad != 0) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Padding fields must be zeroed");
-         return -EINVAL;
-     }
- 
-@@ -1485,27 +1445,17 @@ int nv_drm_semsurf_fence_create_ioctl(st
-     }
- 
-     if (p->__pad != 0) {
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Padding fields must be zeroed");
-         goto done;
-     }
- 
-     if ((nv_fence_context = __nv_drm_fence_context_lookup(
-                                 filep,
-                                 p->fence_context_handle)) == NULL) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for fence context: 0x%08x",
--            p->fence_context_handle);
- 
-         goto done;
-     }
- 
-     if (nv_fence_context->ops != &nv_drm_semsurf_fence_ctx_ops) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Wrong fence context type: 0x%08x",
--            p->fence_context_handle);
--
-         goto fence_context_create_fence_failed;
-     }
- 
-@@ -1518,21 +1468,12 @@ int nv_drm_semsurf_fence_create_ioctl(st
-     if (IS_ERR(fence)) {
-         ret = PTR_ERR(fence);
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate fence: 0x%08x", p->fence_context_handle);
--
-         goto fence_context_create_fence_failed;
-     }
- 
-     if ((fd = nv_drm_create_sync_file(fence)) < 0) {
-         ret = fd;
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to create sync file from fence on ctx 0x%08x",
--            p->fence_context_handle);
--
-         goto fence_context_create_sync_failed;
-     }
- 
-@@ -1592,11 +1533,6 @@ __nv_drm_semsurf_wait_fence_work_cb
-                                                   wait_data->post_wait_value,
-                                                   NULL);
- 
--    if (ret != NVKMS_KAPI_REG_WAITER_SUCCESS) {
--        NV_DRM_DEV_LOG_ERR(nv_dev,
--                           "Failed to register auto-value-update on pre-wait value for sync FD semaphore surface");
--    }
--
-     __nv_drm_semsurf_free_wait_data(wait_data);
- }
- 
-@@ -1650,30 +1586,16 @@ int nv_drm_semsurf_fence_wait_ioctl(stru
-     }
- 
-     if (p->pre_wait_value >= p->post_wait_value) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Non-monotonic wait values specified to fence wait: 0x%" NvU64_fmtu ", 0x%" NvU64_fmtu,
--            p->pre_wait_value, p->post_wait_value);
-         goto done;
-     }
- 
-     if ((nv_fence_context = __nv_drm_fence_context_lookup(
-                                 filep,
-                                 p->fence_context_handle)) == NULL) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for fence context: 0x%08x",
--            p->fence_context_handle);
--
-         goto done;
-     }
- 
-     if (nv_fence_context->ops != &nv_drm_semsurf_fence_ctx_ops) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Wrong fence context type: 0x%08x",
--            p->fence_context_handle);
--
-         goto fence_context_sync_lookup_failed;
-     }
- 
-@@ -1682,20 +1604,12 @@ int nv_drm_semsurf_fence_wait_ioctl(stru
-     wait_data = nv_drm_calloc(1, sizeof(*wait_data));
- 
-     if (!wait_data) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate callback data for sync FD wait: %d", p->fd);
--
-         goto fence_context_sync_lookup_failed;
-     }
- 
-     fence = nv_drm_sync_file_get_fence(p->fd);
- 
-     if (!fence) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Attempt to wait on invalid sync FD: %d", p->fd);
--
-         goto fence_context_sync_lookup_failed;
-     }
- 
-@@ -1717,10 +1631,6 @@ int nv_drm_semsurf_fence_wait_ioctl(stru
-     if (ret) {
-        if (ret == -ENOENT) {
-            /* The fence is already signaled */
--       } else {
--           NV_DRM_LOG_ERR(
--               "Failed to add dma_fence callback. Signaling early!");
--           /* Proceed as if the fence wait succeeded */
-        }
- 
-        /* Execute second half of wait immediately, avoiding the worker thread */
-@@ -1764,11 +1674,6 @@ int nv_drm_semsurf_fence_attach_ioctl(st
-     nv_gem = nv_drm_gem_object_lookup(filep, p->handle);
- 
-     if (!nv_gem) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for fence attach: 0x%08x",
--            p->handle);
--
-         goto done;
-     }
- 
-@@ -1777,20 +1682,10 @@ int nv_drm_semsurf_fence_attach_ioctl(st
-         p->fence_context_handle);
- 
-     if (!nv_fence_context) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for fence context: 0x%08x",
--            p->fence_context_handle);
--
-         goto done;
-     }
- 
-     if (nv_fence_context->ops != &nv_drm_semsurf_fence_ctx_ops) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Wrong fence context type: 0x%08x",
--            p->fence_context_handle);
--
-         goto done;
-     }
- 
-@@ -1803,10 +1698,6 @@ int nv_drm_semsurf_fence_attach_ioctl(st
-     if (IS_ERR(fence)) {
-         ret = PTR_ERR(fence);
- 
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate fence: 0x%08x", p->handle);
--
-         goto done;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-gem.c b/nvidia-drm/nvidia-drm-gem.c
---- a/nvidia-drm/nvidia-drm-gem.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-gem.c	2025-12-18 14:30:00.394549688 +0100
-@@ -224,10 +224,6 @@ int nv_drm_gem_map_offset_ioctl(struct d
- 
-     if ((nv_gem = nv_drm_gem_object_lookup(filep,
-                                            params->handle)) == NULL) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for map: 0x%08x",
--            params->handle);
-         return -EINVAL;
-     }
- 
-@@ -235,10 +231,6 @@ int nv_drm_gem_map_offset_ioctl(struct d
-     if (nv_gem->ops->create_mmap_offset) {
-         ret = nv_gem->ops->create_mmap_offset(nv_dev, nv_gem, &params->offset);
-     } else {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Gem object type does not support mapping: 0x%08x",
--            params->handle);
-         ret = -EINVAL;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-gem-dma-buf.c b/nvidia-drm/nvidia-drm-gem-dma-buf.c
---- a/nvidia-drm/nvidia-drm-gem-dma-buf.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-gem-dma-buf.c	2025-12-18 14:31:15.578919216 +0100
-@@ -181,17 +181,12 @@ int nv_drm_gem_export_dmabuf_memory_ioct
- 
-     if (p->__pad != 0) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Padding fields must be zeroed");
-         goto done;
-     }
- 
-     if ((nv_dma_buf = nv_drm_gem_object_dma_buf_lookup(
-              filep, p->handle)) == NULL) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup DMA-BUF GEM object for export: 0x%08x",
--            p->handle);
-         goto done;
-     }
- 
-@@ -212,10 +207,6 @@ int nv_drm_gem_export_dmabuf_memory_ioct
- 
-     if (!nv_dma_buf->base.pMemory && !pTmpMemory) {
-         ret = -ENOMEM;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to get memory to export from DMA-BUF GEM object: 0x%08x",
--            p->handle);
-         goto done;
-     }
- 
-@@ -225,10 +216,6 @@ int nv_drm_gem_export_dmabuf_memory_ioct
-                              p->nvkms_params_ptr,
-                              p->nvkms_params_size)) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to export memory from DMA-BUF GEM object: 0x%08x",
--            p->handle);
-         goto done;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-gem.h b/nvidia-drm/nvidia-drm-gem.h
---- a/nvidia-drm/nvidia-drm-gem.h	2025-11-21 14:03:10.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-gem.h	2025-12-18 14:29:42.186168958 +0100
-@@ -114,10 +114,6 @@ static inline int nv_drm_gem_create_mmap
-     int ret;
- 
-     if ((ret = drm_gem_create_mmap_offset(&nv_gem->base)) < 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_gem->nv_dev,
--            "drm_gem_create_mmap_offset failed with error code %d",
--            ret);
-         goto done;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-gem-nvkms-memory.c b/nvidia-drm/nvidia-drm-gem-nvkms-memory.c
---- a/nvidia-drm/nvidia-drm-gem-nvkms-memory.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-gem-nvkms-memory.c	2025-12-18 14:30:58.882992353 +0100
-@@ -180,10 +180,6 @@ static int __nv_drm_gem_nvkms_map(
-                           pMemory,
-                           NVKMS_KAPI_MAPPING_TYPE_USER,
-                           &nv_nvkms_memory->pPhysicalAddress)) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to map NvKmsKapiMemory 0x%p",
--            pMemory);
-         ret = -ENOMEM;
-         goto done;
-     }
-@@ -300,11 +296,6 @@ static int __nv_drm_nvkms_gem_obj_init(
-     NvU32 numPages = 0;
- 
-     if ((size % PAGE_SIZE) != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "NvKmsKapiMemory 0x%p size should be in a multiple of page size to "
--            "create a gem object",
--            pMemory);
-         return -EINVAL;
-     }
- 
-@@ -320,9 +311,6 @@ static int __nv_drm_nvkms_gem_obj_init(
-                                &numPages)) {
-         /* GetMemoryPages will fail for vidmem allocations,
-          * but it should not fail for sysmem allocations. */
--        NV_DRM_DEV_LOG_ERR(nv_dev,
--            "Failed to get memory pages for NvKmsKapiMemory 0x%p",
--            pMemory);
-         return -ENOMEM;
-     }
-     nv_nvkms_memory->pages_count = numPages;
-@@ -373,10 +361,6 @@ int nv_drm_dumb_create(
-     pMemory = nvKms->allocateMemory(nv_dev->pDevice, &allocParams);
-     if (pMemory == NULL) {
-         ret = -ENOMEM;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to allocate NvKmsKapiMemory for dumb object of size %" NvU64_fmtu,
--            args->size);
-         goto nvkms_alloc_memory_failed;
-     }
- 
-@@ -436,9 +420,6 @@ int nv_drm_gem_import_nvkms_memory_ioctl
- 
-     if (pMemory == NULL) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to import NVKMS memory to GEM object");
-         goto nvkms_import_memory_failed;
-     }
- 
-@@ -475,7 +456,6 @@ int nv_drm_gem_export_nvkms_memory_ioctl
- 
-     if (p->__pad != 0) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(nv_dev, "Padding fields must be zeroed");
-         goto done;
-     }
- 
-@@ -483,10 +463,6 @@ int nv_drm_gem_export_nvkms_memory_ioctl
-                     filep,
-                     p->handle)) == NULL) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup NVKMS gem object for export: 0x%08x",
--            p->handle);
-         goto done;
-     }
- 
-@@ -495,9 +471,6 @@ int nv_drm_gem_export_nvkms_memory_ioctl
-                              p->nvkms_params_ptr,
-                              p->nvkms_params_size)) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to export memory from NVKMS GEM object: 0x%08x", p->handle);
-         goto done;
-     }
- 
-@@ -526,7 +499,6 @@ int nv_drm_gem_alloc_nvkms_memory_ioctl(
- 
-     if ((p->__pad0 != 0) || (p->__pad1 != 0)) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(nv_dev, "non-zero value in padding field");
-         goto failed;
-     }
- 
-@@ -547,8 +519,6 @@ int nv_drm_gem_alloc_nvkms_memory_ioctl(
-     pMemory = nvKms->allocateMemory(nv_dev->pDevice, &allocParams);
-     if (pMemory == NULL) {
-         ret = -EINVAL;
--        NV_DRM_DEV_LOG_ERR(nv_dev,
--                           "Failed to allocate NVKMS memory for GEM object");
-         goto nvkms_alloc_memory_failed;
-     }
- 
-@@ -593,9 +563,6 @@ static struct drm_gem_object *__nv_drm_g
-     pMemory = nvKms->dupMemory(nv_dev->pDevice,
-                                nv_dev_src->pDevice, nv_gem_src->pMemory);
-     if (pMemory == NULL) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to import NVKMS memory to GEM object");
-         goto nvkms_dup_memory_failed;
-     }
- 
-@@ -628,10 +595,6 @@ int nv_drm_dumb_map_offset(struct drm_fi
-     if ((nv_nvkms_memory = nv_drm_gem_object_nvkms_memory_lookup(
-                     file,
-                     handle)) == NULL) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lookup gem object for mapping: 0x%08x",
--            handle);
-         return ret;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-gem-user-memory.c b/nvidia-drm/nvidia-drm-gem-user-memory.c
---- a/nvidia-drm/nvidia-drm-gem-user-memory.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-gem-user-memory.c	2025-12-18 14:30:15.577862757 +0100
-@@ -196,11 +196,6 @@ int nv_drm_gem_import_userspace_memory_i
-     int ret = 0;
- 
-     if ((params->size % PAGE_SIZE) != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Userspace memory 0x%" NvU64_fmtx " size should be in a multiple of page "
--            "size to create a gem object",
--            params->address);
-         return -EINVAL;
-     }
- 
-@@ -209,10 +204,6 @@ int nv_drm_gem_import_userspace_memory_i
-     ret = nv_drm_lock_user_pages(params->address, pages_count, &pages);
- 
-     if (ret != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to lock user pages for address 0x%" NvU64_fmtx ": %d",
--            params->address, ret);
-         return ret;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-modeset.c b/nvidia-drm/nvidia-drm-modeset.c
---- a/nvidia-drm/nvidia-drm-modeset.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-modeset.c	2025-12-18 14:29:22.106108962 +0100
-@@ -247,9 +247,6 @@ static int __nv_drm_convert_in_fences(
-         }
- 
-         if (idx_count == nv_dev->display_semaphores.count) {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to initialize semaphore for plane fence");
-             /*
-              * This should only happen if the semaphore pool was somehow
-              * exhausted. Waiting a bit and retrying may help in that case.
-@@ -263,9 +260,6 @@ static int __nv_drm_convert_in_fences(
-         fence_data = nv_drm_calloc(1, sizeof(*fence_data));
- 
-         if (!fence_data) {
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed to allocate callback data for plane fence");
-             nvKms->cancelDisplaySemaphore(nv_dev->pDevice, semaphore_index);
-             return -ENOMEM;
-         }
-@@ -295,9 +289,6 @@ static int __nv_drm_convert_in_fences(
-             plane_state->fence = NULL;
-             break;
-         default:
--            NV_DRM_DEV_LOG_ERR(
--                nv_dev,
--                "Failed plane fence callback registration");
-             /* Fence callback registration failed */
-             nvKms->cancelDisplaySemaphore(nv_dev->pDevice, semaphore_index);
-             nv_drm_free(fence_data);
-@@ -677,9 +668,6 @@ int nv_drm_atomic_commit(struct drm_devi
-                     nv_dev->flip_event_wq,
-                     list_empty(&nv_crtc->flip_list),
-                     3 * HZ /* 3 second */) == 0) {
--                NV_DRM_DEV_LOG_ERR(
--                    nv_dev,
--                    "Flip event timeout on head %u", nv_crtc->head);
-             }
-         }
- 
-@@ -696,14 +684,6 @@ int nv_drm_atomic_commit(struct drm_devi
-             if (!complete) {
-                 if (nonblock) {
-                     return -EBUSY;
--                } else {
--                    /*
--                     * checkLutNotifier should wait on the notifier in this
--                     * case, so we should only get here if the wait timed out.
--                     */
--                    NV_DRM_DEV_LOG_ERR(
--                        nv_dev,
--                        "LUT notifier timeout on head %u", nv_crtc->head);
-                 }
-             }
-         }
-@@ -740,10 +720,6 @@ int nv_drm_atomic_commit(struct drm_devi
-     if ((ret = nv_drm_atomic_apply_modeset_config(
-                     dev,
-                     state, true /* commit */)) != 0) {
--        NV_DRM_DEV_LOG_ERR(
--            nv_dev,
--            "Failed to apply atomic modeset.  Error code: %d",
--            ret);
- 
-         goto done;
-     }
-@@ -824,9 +800,6 @@ int nv_drm_atomic_commit(struct drm_devi
-                     nv_dev->flip_event_wq,
-                     list_empty(&nv_crtc->flip_list),
-                     3 * HZ /* 3 second */) == 0) {
--                NV_DRM_DEV_LOG_ERR(
--                    nv_dev,
--                    "Flip event timeout on head %u", nv_crtc->head);
-                 while (!list_empty(&nv_crtc->flip_list)) {
-                     __nv_drm_handle_flip_event(nv_crtc);
-                 }
-@@ -836,11 +809,6 @@ int nv_drm_atomic_commit(struct drm_devi
-                 NvBool complete = nvKms->checkLutNotifier(nv_dev->pDevice,
-                                                           nv_crtc->head,
-                                                           true /* waitForCompletion */);
--                if (!complete) {
--                    NV_DRM_DEV_LOG_ERR(
--                        nv_dev,
--                        "LUT notifier timeout on head %u", nv_crtc->head);
--                }
-             }
-         }
-     }
diff -rupN a/patches/OLD/drm_error.patch.v1 b/patches/OLD/drm_error.patch.v1
--- a/patches/OLD/drm_error.patch.v1	2025-12-18 14:25:32.011272282 +0100
+++ b/patches/OLD/drm_error.patch.v1	1970-01-01 01:00:00.000000000 +0100
@@ -1,124 +0,0 @@
-diff -rupN a/nvidia-drm/nvidia-drm.c b/nvidia-drm/nvidia-drm.c
---- a/nvidia-drm/nvidia-drm.c	2025-11-21 14:03:08.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm.c	2025-12-18 14:23:03.151361107 +0100
-@@ -45,9 +45,6 @@ int nv_drm_init(void)
- {
- #if defined(NV_DRM_AVAILABLE)
-     if (!nvKmsKapiGetFunctionsTable(&nvKmsFuncsTable)) {
--        NV_DRM_LOG_ERR(
--            "Version mismatch: nvidia-modeset.ko(%s) nvidia-drm.ko(%s)",
--            nvKmsFuncsTable.versionString, NV_VERSION_STRING);
-         return -EINVAL;
-     }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-connector.c b/nvidia-drm/nvidia-drm-connector.c
---- a/nvidia-drm/nvidia-drm-connector.c	2025-11-21 14:03:11.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-connector.c	2025-12-18 14:25:12.232372256 +0100
-@@ -139,8 +139,6 @@ __nv_drm_detect_encoder(struct NvKmsKapi
-                 memcpy(nv_connector->edid,
-                        pDetectParams->edid.buffer,
-                        pDetectParams->edid.bufferSize);
--            } else {
--                NV_DRM_LOG_ERR("Out of Memory");
-             }
-         }
- 
-diff -rupN a/nvidia-drm/nvidia-drm-drv.c b/nvidia-drm/nvidia-drm-drv.c
---- a/nvidia-drm/nvidia-drm-drv.c	2025-11-21 14:03:11.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-drv.c	2025-12-18 14:24:57.224223857 +0100
-@@ -522,7 +522,6 @@ static int nv_drm_create_properties(stru
-         drm_property_create_enum(nv_dev->dev, 0, "NV_INPUT_COLORSPACE",
-                                  colorspace_enum_list, len);
-     if (nv_dev->nv_input_colorspace_property == NULL) {
--        NV_DRM_LOG_ERR("Failed to create NV_INPUT_COLORSPACE property");
-         return -ENOMEM;
-     }
- 
-@@ -1975,8 +1974,6 @@ void nv_drm_register_drm_device(const st
-     nv_dev = nv_drm_calloc(1, sizeof(*nv_dev));
- 
-     if (nv_dev == NULL) {
--        NV_DRM_LOG_ERR(
--            "Failed to allocate memory for NVIDIA-DRM device object");
-         return;
-     }
- 
-@@ -2108,10 +2105,6 @@ int nv_drm_probe_devices(void)
-     /* Register DRM device for each NVIDIA GPU available via NVKMS. */
-     gpu_count = nvKms->enumerateGpus(nv_drm_register_drm_device);
- 
--    if (gpu_count == 0) {
--        NV_DRM_LOG_INFO("No NVIDIA GPUs found");
--    }
--
-     return 0;
- }
- #endif
-diff -rupN a/nvidia-drm/nvidia-drm-fence.c b/nvidia-drm/nvidia-drm-fence.c
---- a/nvidia-drm/nvidia-drm-fence.c	2025-11-21 14:03:12.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-fence.c	2025-12-18 14:24:32.072062150 +0100
-@@ -503,8 +503,6 @@ static int __nv_drm_gem_attach_fence(str
-         } else {
-             nv_dma_resv_add_excl_fence(resv, fence);
-         }
--    } else {
--        NV_DRM_LOG_ERR("Failed to reserve fence. Error code: %d", ret);
-     }
- 
-     nv_dma_resv_unlock(resv);
-@@ -1717,10 +1715,6 @@ int nv_drm_semsurf_fence_wait_ioctl(stru
-     if (ret) {
-        if (ret == -ENOENT) {
-            /* The fence is already signaled */
--       } else {
--           NV_DRM_LOG_ERR(
--               "Failed to add dma_fence callback. Signaling early!");
--           /* Proceed as if the fence wait succeeded */
-        }
- 
-        /* Execute second half of wait immediately, avoiding the worker thread */
-diff -rupN a/nvidia-drm/nvidia-drm-priv.h b/nvidia-drm/nvidia-drm-priv.h
---- a/nvidia-drm/nvidia-drm-priv.h	2025-11-21 14:03:09.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-priv.h	2025-12-18 14:24:04.015974547 +0100
-@@ -38,41 +38,6 @@
- 
- #include "nvkms-kapi.h"
- 
--#define NV_DRM_LOG_ERR(__fmt, ...) \
--    DRM_ERROR("[nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
--
--/*
-- * DRM_WARN() was added in v4.9 by kernel commit
-- * 30b0da8d556e65ff935a56cd82c05ba0516d3e4a
-- *
-- * Before this commit, only DRM_INFO and DRM_ERROR were defined and
-- * DRM_INFO(fmt, ...) was defined as
-- * printk(KERN_INFO "[" DRM_NAME "] " fmt, ##__VA_ARGS__). So, if
-- * DRM_WARN is undefined this defines NV_DRM_LOG_WARN following the
-- * same pattern as DRM_INFO.
-- */
--#ifdef DRM_WARN
--#define NV_DRM_LOG_WARN(__fmt, ...) \
--    DRM_WARN("[nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
--#else
--#define NV_DRM_LOG_WARN(__fmt, ...) \
--    printk(KERN_WARNING "[" DRM_NAME "] [nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
--#endif
--
--#define NV_DRM_LOG_INFO(__fmt, ...) \
--    DRM_INFO("[nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
--
--#define NV_DRM_DEV_LOG_INFO(__dev, __fmt, ...) \
--    NV_DRM_LOG_INFO("[GPU ID 0x%08x] " __fmt, __dev->gpu_info.gpu_id, ##__VA_ARGS__)
--
--#define NV_DRM_DEV_LOG_WARN(__dev, __fmt, ...) \
--    NV_DRM_LOG_WARN("[GPU ID 0x%08x] " __fmt, __dev->gpu_info.gpu_id, ##__VA_ARGS__)
--
--#define NV_DRM_DEV_LOG_ERR(__dev, __fmt, ...) \
--    NV_DRM_LOG_ERR("[GPU ID 0x%08x] " __fmt, __dev->gpu_info.gpu_id, ##__VA_ARGS__)
--
--#define NV_DRM_WARN(__condition) WARN_ON((__condition))
--
- #define NV_DRM_DEBUG_DRIVER(__fmt, ...) \
-     DRM_DEBUG_DRIVER("[nvidia-drm] " __fmt "\n", ##__VA_ARGS__)
- 
diff -rupN a/patches/OLD/gpl.patch b/patches/OLD/gpl.patch
--- a/patches/OLD/gpl.patch	2025-12-18 15:30:44.244927329 +0100
+++ b/patches/OLD/gpl.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-diff -rupN a/nvidia/nv.c b/nvidia/nv.c
---- a/nvidia/nv.c	2025-11-21 14:44:33.000000000 +0100
-+++ b/nvidia/nv.c	2025-12-18 15:29:02.860319472 +0100
-@@ -115,7 +115,7 @@
- 
- #define TEGRA264_STRAP_NV_FUSE_CTRL_OPT_GPU 1U
- 
--MODULE_LICENSE("NVIDIA");
-+MODULE_LICENSE("GPL");
- 
- MODULE_INFO(supported, "external");
- MODULE_VERSION(NV_VERSION_STRING);
-diff -rupN a/nvidia-drm/nvidia-drm-linux.c b/nvidia-drm/nvidia-drm-linux.c
---- a/nvidia-drm/nvidia-drm-linux.c	2025-11-21 14:03:04.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-linux.c	2025-12-18 15:28:36.690858170 +0100
-@@ -60,7 +60,7 @@ static void __exit nv_linux_drm_exit(voi
- module_init(nv_linux_drm_init);
- module_exit(nv_linux_drm_exit);
- 
--  MODULE_LICENSE("MIT");
-+  MODULE_LICENSE("GPL");
- 
- MODULE_INFO(supported, "external");
- MODULE_VERSION(NV_VERSION_STRING);
-diff -rupN a/nvidia-modeset/nvidia-modeset-linux.c b/nvidia-modeset/nvidia-modeset-linux.c
---- a/nvidia-modeset/nvidia-modeset-linux.c	2025-11-21 13:59:45.000000000 +0100
-+++ b/nvidia-modeset/nvidia-modeset-linux.c	2025-12-18 15:29:24.491449162 +0100
-@@ -2233,7 +2233,7 @@ restart:
- module_init(nvkms_init);
- module_exit(nvkms_exit);
- 
--  MODULE_LICENSE("NVIDIA");
-+  MODULE_LICENSE("GPL");
- 
- MODULE_INFO(supported, "external");
- MODULE_VERSION(NV_VERSION_STRING);
-diff -rupN a/nvidia-peermem/nvidia-peermem.c b/nvidia-peermem/nvidia-peermem.c
---- a/nvidia-peermem/nvidia-peermem.c	2025-11-21 14:04:16.000000000 +0100
-+++ b/nvidia-peermem/nvidia-peermem.c	2025-12-18 15:30:21.596100864 +0100
-@@ -44,7 +44,7 @@
- MODULE_AUTHOR("Yishai Hadas");
- MODULE_DESCRIPTION("NVIDIA GPU memory plug-in");
- 
--MODULE_LICENSE("Linux-OpenIB");
-+MODULE_LICENSE("GPL");
- 
- MODULE_VERSION(DRV_VERSION);
- enum {
-diff -rupN a/nvidia-uvm/uvm.c b/nvidia-uvm/uvm.c
---- a/nvidia-uvm/uvm.c	2025-11-21 14:44:09.000000000 +0100
-+++ b/nvidia-uvm/uvm.c	2025-12-18 15:30:00.068019420 +0100
-@@ -1229,6 +1229,6 @@ static void __exit uvm_exit_entry(void)
- module_init(uvm_init_entry);
- module_exit(uvm_exit_entry);
- 
--MODULE_LICENSE("Dual MIT/GPL");
-+MODULE_LICENSE("GPL");
- MODULE_INFO(supported, "external");
- MODULE_VERSION(NV_VERSION_STRING);
diff -rupN a/patches/rg.patch b/patches/rg.patch
--- a/patches/rg.patch	2025-12-19 13:59:50.622968151 +0100
+++ b/patches/rg.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-diff -rupN a/common/inc/nv-mm.h b/common/inc/nv-mm.h
---- a/common/inc/nv-mm.h	2025-11-21 14:44:03.000000000 +0100
-+++ b/common/inc/nv-mm.h	2025-12-19 13:31:23.947089487 +0100
-@@ -204,26 +204,12 @@ void nv_vma_start_write(struct vm_area_s
- 
- static inline void nv_vm_flags_set(struct vm_area_struct *vma, vm_flags_t flags)
- {
--#if !NV_CAN_CALL_VMA_START_WRITE
--    nv_vma_start_write(vma);
--    ACCESS_PRIVATE(vma, __vm_flags) |= flags;
--#elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
-     vm_flags_set(vma, flags);
--#else
--    vma->vm_flags |= flags;
--#endif
- }
- 
- static inline void nv_vm_flags_clear(struct vm_area_struct *vma, vm_flags_t flags)
- {
--#if !NV_CAN_CALL_VMA_START_WRITE
--    nv_vma_start_write(vma);
--    ACCESS_PRIVATE(vma, __vm_flags) &= ~flags;
--#elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
-     vm_flags_clear(vma, flags);
--#else
--    vma->vm_flags &= ~flags;
--#endif
- }
- 
- #endif // __NV_MM_H__
-diff -rupN a/nvidia/nv-dma.c b/nvidia/nv-dma.c
---- a/nvidia/nv-dma.c	2025-11-21 14:44:33.000000000 +0100
-+++ b/nvidia/nv-dma.c	2025-12-19 13:31:56.059311442 +0100
-@@ -729,7 +729,7 @@ static NvBool nv_dma_use_map_resource
- #endif
-     }
- 
--    return (ops->map_resource != NULL);
-+    return NV_TRUE;
- }
- 
- /* DMA-map a peer device's C2C aperture for peer access. */
-diff -rupN a/nvidia-drm/nvidia-drm-helper.h b/nvidia-drm/nvidia-drm-helper.h
---- a/nvidia-drm/nvidia-drm-helper.h	2025-11-21 14:03:09.000000000 +0100
-+++ b/nvidia-drm/nvidia-drm-helper.h	2025-12-19 13:59:21.060555577 +0100
-@@ -196,7 +196,7 @@ int nv_drm_atomic_helper_disable_all(str
-        for ((__i) = 0;                                                      \
-             (__i) < (__state)->num_connector &&                             \
-             ((connector) = (__state)->connectors[__i].ptr,                  \
--            (connector_state) = (__state)->connectors[__i].state, 1);       \
-+            (connector_state) = (__state)->connectors[__i].new_state, 1);       \
-             (__i)++)                                                        \
-                for_each_if (connector)
- #else
-@@ -223,7 +223,7 @@ int nv_drm_atomic_helper_disable_all(str
-        for ((__i) = 0;                                                \
-             (__i) < (__state)->dev->mode_config.num_crtc &&           \
-             ((crtc) = (__state)->crtcs[__i].ptr,                      \
--            (crtc_state) = (__state)->crtcs[__i].state, 1);           \
-+            (crtc_state) = (__state)->crtcs[__i].new_state, 1);           \
-             (__i)++)                                                  \
-                for_each_if (crtc_state)
- #else
-@@ -248,7 +248,7 @@ int nv_drm_atomic_helper_disable_all(str
-        for ((__i) = 0;                                                   \
-             (__i) < (__state)->dev->mode_config.num_total_plane &&       \
-             ((plane) = (__state)->planes[__i].ptr,                       \
--            (plane_state) = (__state)->planes[__i].state, 1);            \
-+            (plane_state) = (__state)->planes[__i].new_state, 1);            \
-             (__i)++)                                                     \
-                for_each_if (plane_state)
- #else
-diff -rupN a/nvidia-uvm/uvm.c b/nvidia-uvm/uvm.c
---- a/nvidia-uvm/uvm.c	2025-11-21 14:44:09.000000000 +0100
-+++ b/nvidia-uvm/uvm.c	2025-12-19 13:38:38.797307999 +0100
-@@ -1229,6 +1229,6 @@ static void __exit uvm_exit_entry(void)
- module_init(uvm_init_entry);
- module_exit(uvm_exit_entry);
- 
--MODULE_LICENSE("Dual MIT/GPL");
-+MODULE_LICENSE("GPL");
- MODULE_INFO(supported, "external");
- MODULE_VERSION(NV_VERSION_STRING);
diff -rupN a/patches/vmflags.patch b/patches/vmflags.patch
--- a/patches/vmflags.patch	2025-12-07 16:41:42.692161702 +0100
+++ b/patches/vmflags.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-diff -rupN a/common/inc/nv-mm.h b/common/inc/nv-mm.h
---- a/common/inc/nv-mm.h	2025-10-30 00:08:36.000000000 +0100
-+++ b/common/inc/nv-mm.h	2025-11-28 11:56:41.456719493 +0100
-@@ -206,7 +206,7 @@ static inline void nv_vm_flags_set(struc
- {
- #if !NV_CAN_CALL_VMA_START_WRITE
-     nv_vma_start_write(vma);
--    ACCESS_PRIVATE(vma, __vm_flags) |= flags;
-+    vma_flags_set_word(&vma->flags, flags);
- #elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
-     vm_flags_set(vma, flags);
- #else
-@@ -218,7 +218,7 @@ static inline void nv_vm_flags_clear(str
- {
- #if !NV_CAN_CALL_VMA_START_WRITE
-     nv_vma_start_write(vma);
--    ACCESS_PRIVATE(vma, __vm_flags) &= ~flags;
-+    vma_flags_clear_word(&vma->flags, flags);
- #elif defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
-     vm_flags_clear(vma, flags);
- #else
